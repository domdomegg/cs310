<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_n1icddiwhh1h-4{list-style-type:none}.lst-kix_v69dk6nyi3uu-7>li:before{content:"\0025cb  "}ul.lst-kix_n1icddiwhh1h-3{list-style-type:none}ul.lst-kix_n1icddiwhh1h-6{list-style-type:none}ul.lst-kix_v69dk6nyi3uu-1{list-style-type:none}ul.lst-kix_n1icddiwhh1h-5{list-style-type:none}ul.lst-kix_v69dk6nyi3uu-0{list-style-type:none}ul.lst-kix_n1icddiwhh1h-0{list-style-type:none}ul.lst-kix_v69dk6nyi3uu-3{list-style-type:none}ul.lst-kix_v69dk6nyi3uu-2{list-style-type:none}ul.lst-kix_n1icddiwhh1h-2{list-style-type:none}ul.lst-kix_v69dk6nyi3uu-5{list-style-type:none}.lst-kix_v69dk6nyi3uu-8>li:before{content:"\0025a0  "}ul.lst-kix_n1icddiwhh1h-1{list-style-type:none}.lst-kix_v69dk6nyi3uu-4>li:before{content:"\0025cb  "}ul.lst-kix_v69dk6nyi3uu-4{list-style-type:none}.lst-kix_v69dk6nyi3uu-3>li:before{content:"\0025cf  "}ul.lst-kix_n1icddiwhh1h-8{list-style-type:none}ul.lst-kix_n1icddiwhh1h-7{list-style-type:none}.lst-kix_v69dk6nyi3uu-2>li:before{content:"\0025a0  "}.lst-kix_d6ra4nqnljxz-8>li:before{content:"\0025a0  "}.lst-kix_v69dk6nyi3uu-1>li:before{content:"\0025cb  "}.lst-kix_v69dk6nyi3uu-0>li:before{content:"\0025cf  "}ul.lst-kix_v69dk6nyi3uu-7{list-style-type:none}ul.lst-kix_v69dk6nyi3uu-6{list-style-type:none}ul.lst-kix_v69dk6nyi3uu-8{list-style-type:none}ul.lst-kix_d6ra4nqnljxz-1{list-style-type:none}ul.lst-kix_d6ra4nqnljxz-2{list-style-type:none}ul.lst-kix_d6ra4nqnljxz-3{list-style-type:none}ul.lst-kix_d6ra4nqnljxz-4{list-style-type:none}ul.lst-kix_d6ra4nqnljxz-5{list-style-type:none}ul.lst-kix_d6ra4nqnljxz-6{list-style-type:none}ul.lst-kix_d6ra4nqnljxz-7{list-style-type:none}ul.lst-kix_d6ra4nqnljxz-8{list-style-type:none}ul.lst-kix_d6ra4nqnljxz-0{list-style-type:none}ul.lst-kix_f9hviix50sbl-6{list-style-type:none}ul.lst-kix_f9hviix50sbl-7{list-style-type:none}ul.lst-kix_f9hviix50sbl-8{list-style-type:none}.lst-kix_n1icddiwhh1h-0>li:before{content:"\0025cf  "}.lst-kix_n1icddiwhh1h-1>li:before{content:"\0025cb  "}.lst-kix_n1icddiwhh1h-3>li:before{content:"\0025cf  "}.lst-kix_n1icddiwhh1h-2>li:before{content:"\0025a0  "}ul.lst-kix_f9hviix50sbl-2{list-style-type:none}ul.lst-kix_f9hviix50sbl-3{list-style-type:none}ul.lst-kix_f9hviix50sbl-4{list-style-type:none}ul.lst-kix_f9hviix50sbl-5{list-style-type:none}ul.lst-kix_f9hviix50sbl-0{list-style-type:none}ul.lst-kix_f9hviix50sbl-1{list-style-type:none}.lst-kix_d6ra4nqnljxz-0>li:before{content:"\0025cf  "}.lst-kix_d6ra4nqnljxz-1>li:before{content:"\0025cb  "}.lst-kix_d6ra4nqnljxz-7>li:before{content:"\0025cb  "}.lst-kix_d6ra4nqnljxz-6>li:before{content:"\0025cf  "}.lst-kix_n1icddiwhh1h-5>li:before{content:"\0025a0  "}.lst-kix_n1icddiwhh1h-7>li:before{content:"\0025cb  "}.lst-kix_d6ra4nqnljxz-5>li:before{content:"\0025a0  "}.lst-kix_n1icddiwhh1h-4>li:before{content:"\0025cb  "}.lst-kix_n1icddiwhh1h-8>li:before{content:"\0025a0  "}.lst-kix_d6ra4nqnljxz-3>li:before{content:"\0025cf  "}.lst-kix_d6ra4nqnljxz-2>li:before{content:"\0025a0  "}.lst-kix_d6ra4nqnljxz-4>li:before{content:"\0025cb  "}.lst-kix_v69dk6nyi3uu-5>li:before{content:"\0025a0  "}.lst-kix_v69dk6nyi3uu-6>li:before{content:"\0025cf  "}.lst-kix_n1icddiwhh1h-6>li:before{content:"\0025cf  "}.lst-kix_7lyu6nf8ijma-8>li:before{content:"\0025a0  "}.lst-kix_7lyu6nf8ijma-7>li:before{content:"\0025cb  "}.lst-kix_u6w4ccd2asj5-2>li:before{content:"\0025a0  "}.lst-kix_u6w4ccd2asj5-4>li:before{content:"\0025cb  "}.lst-kix_7lyu6nf8ijma-6>li:before{content:"\0025cf  "}.lst-kix_u6w4ccd2asj5-3>li:before{content:"\0025cf  "}.lst-kix_u6w4ccd2asj5-7>li:before{content:"\0025cb  "}.lst-kix_u6w4ccd2asj5-0>li:before{content:"\0025cf  "}.lst-kix_u6w4ccd2asj5-8>li:before{content:"\0025a0  "}.lst-kix_u6w4ccd2asj5-1>li:before{content:"\0025cb  "}ul.lst-kix_u6w4ccd2asj5-8{list-style-type:none}ul.lst-kix_u6w4ccd2asj5-7{list-style-type:none}ul.lst-kix_u6w4ccd2asj5-6{list-style-type:none}ul.lst-kix_u6w4ccd2asj5-5{list-style-type:none}ul.lst-kix_u6w4ccd2asj5-4{list-style-type:none}ul.lst-kix_u6w4ccd2asj5-3{list-style-type:none}ul.lst-kix_u6w4ccd2asj5-2{list-style-type:none}ul.lst-kix_u6w4ccd2asj5-1{list-style-type:none}ul.lst-kix_u6w4ccd2asj5-0{list-style-type:none}.lst-kix_f9hviix50sbl-5>li:before{content:"\0025a0  "}.lst-kix_7lyu6nf8ijma-0>li:before{content:"\0025cf  "}.lst-kix_f9hviix50sbl-6>li:before{content:"\0025cf  "}.lst-kix_f9hviix50sbl-7>li:before{content:"\0025cb  "}.lst-kix_7lyu6nf8ijma-1>li:before{content:"\0025cb  "}.lst-kix_7lyu6nf8ijma-2>li:before{content:"\0025a0  "}.lst-kix_f9hviix50sbl-8>li:before{content:"\0025a0  "}.lst-kix_7lyu6nf8ijma-4>li:before{content:"\0025cb  "}.lst-kix_7lyu6nf8ijma-3>li:before{content:"\0025cf  "}.lst-kix_7lyu6nf8ijma-5>li:before{content:"\0025a0  "}.lst-kix_u6w4ccd2asj5-6>li:before{content:"\0025cf  "}.lst-kix_u6w4ccd2asj5-5>li:before{content:"\0025a0  "}ul.lst-kix_7lyu6nf8ijma-3{list-style-type:none}ul.lst-kix_7lyu6nf8ijma-4{list-style-type:none}ul.lst-kix_7lyu6nf8ijma-1{list-style-type:none}ul.lst-kix_7lyu6nf8ijma-2{list-style-type:none}ul.lst-kix_7lyu6nf8ijma-7{list-style-type:none}ul.lst-kix_7lyu6nf8ijma-8{list-style-type:none}ul.lst-kix_7lyu6nf8ijma-5{list-style-type:none}ul.lst-kix_7lyu6nf8ijma-6{list-style-type:none}.lst-kix_f9hviix50sbl-4>li:before{content:"\0025cb  "}ul.lst-kix_7lyu6nf8ijma-0{list-style-type:none}.lst-kix_f9hviix50sbl-2>li:before{content:"\0025a0  "}.lst-kix_f9hviix50sbl-3>li:before{content:"\0025cf  "}.lst-kix_f9hviix50sbl-1>li:before{content:"\0025cb  "}.lst-kix_f9hviix50sbl-0>li:before{content:"\0025cf  "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}ol{margin:0;padding:0}table td,table th{padding:0}.c18{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:112.9pt;border-top-color:#000000;border-bottom-style:solid}.c8{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:90.3pt;border-top-color:#000000;border-bottom-style:solid}.c13{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c27{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:21pt;font-family:"Arial";font-style:normal}.c28{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Arial";font-style:normal}.c22{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c23{padding-top:0pt;padding-bottom:16pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c9{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c6{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c17{color:#434343;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Arial";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c19{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c26{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c30{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Arial";font-style:normal}.c24{padding-top:14pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c15{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c10{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c33{border-spacing:0;border-collapse:collapse;margin-right:auto}.c20{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c25{background-color:#ffffff;max-width:451.4pt;padding:72pt 72pt 72pt 72pt}.c12{color:#1155cc;font-size:10pt}.c14{padding:0;margin:0}.c7{margin-left:36pt;padding-left:0pt}.c29{color:inherit;text-decoration:inherit}.c35{width:33%;height:1px}.c32{background-color:#ffffff;color:#222222}.c31{vertical-align:super}.c11{font-style:italic}.c4{height:11pt}.c34{font-weight:700}.c16{height:0pt}.c21{font-size:10pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c25"><div><p class="c1 c4"><span class="c0"></span></p></div><p class="c26 title" id="h.rl1dsou2c8er"><span class="c27">Interactive Tool for Teaching Hindley-Milner Type Inference through Visualisation</span></p><p class="c23 subtitle" id="h.tjcdwj7drsa5"><span>Final report</span><span><br><br></span><span class="c34">Adam Jones</span><span class="c28"><br>Department of Computer Science<br>University of Warwick</span></p><p class="c1"><span class="c0">TODO: Abstract</span></p><h1 class="c6" id="h.6k9gcmunzldy"><span class="c19">Introduction</span></h1><p class="c1"><span>Types are common features of many programming languages. Generally, types are </span><span>bounds</span><span class="c0">&nbsp;on program constructs (such as variables, expressions and functions) that limit what valid values they may take and how they should be interpreted within the program, however different languages use types differently. Most type systems include primitive data types such as integers, booleans and characters as well as composite types such functions from one type to another and lists of a type.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Type checking is the process by which a language&rsquo;s compiler or interpreter validates that a program obeys the rules of the language&rsquo;s type system. When a violation is detected, such as providing a boolean to a function accepting an integer, a type error is raised.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Type checking is primarily used to catch bugs in program code, preventing unexpected behaviour. A simple example of this is function application: functions&rsquo; types specify how they can be called which ensure some pre-conditions are met, such as the arguments being of an expected type. This allows function implementers to safely assume the data is of that type, and prevents function users calling the function with invalid arguments.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Type checking can happen either at compile time (static type checking) or runtime (dynamic type checking).</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Compile-time type checking prevents many type errors from occurring at runtime. This is particularly useful when code paths may not be well tested or frequently used, as runtime checks only surface type errors when the problematic code is executed. Additionally, knowing types at compile-time allows for better tooling that improves developer productivity. For example, IDEs may use type information to suggest and perform automated refactorings (</span><sup><a href="#ftnt1" id="ftnt_ref1">[1]</a></sup><span>), automatically generate documentation (</span><sup><a href="#ftnt2" id="ftnt_ref2">[2]</a></sup><span>) and autocomplete statements (</span><sup><a href="#ftnt3" id="ftnt_ref3">[3]</a></sup><span class="c0">).</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Compile-time type checking requires the program code to have enough information to validate its type safety. This may be in the form of type annotations or typed variable and function declarations. However, specifying types manually can be time-consuming and potentially difficult as it is additional work for the programmer, and large composite types can be especially difficult to determine and tedious to repeatedly write.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">A type inference algorithm for a programming language&rsquo;s type system can determine types automatically, which improves productivity by allowing programmers to get the best of types without having to explicitly specify them. Because of this, type inference is used in many popular programming languages with expressive type systems including Haskell, Rust and TypeScript.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">An understanding of type inference would help computer scientists write cleaner code and debug type errors. However, few universities have core modules on type systems (although they may be touched on in programming curriculums) and there are limited easy-to-understand teaching resources on type inference. Therefore, many computer science graduates will be missing a useful understanding of how type inference actually works.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The goal of this project is develop a system to visualise the type inference process, with the aim of improving undergraduate students&rsquo; knowledge about it.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">To achieve this, we develop a teaching resource that explains how type inference algorithms work for functional languages. An interactive web application allows students to enter expressions and view the results of a type inference algorithm, along with the steps taken to get to that result. This is particularly useful in the context of modules teaching functional languages such as Haskell which perform similar type inference.</span></p><h2 class="c15" id="h.2mwaav7jkal4"><span class="c22">Related work</span></h2><p class="c1"><span class="c0">There have been previous attempts to build visualisation and teaching tools related to type systems.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 462.20px; height: 500.24px;"><img alt="Screenshot of results from TypeTool, taken from their paper" src="images/image19.png" style="width: 462.20px; height: 500.24px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>One example is TypeTool by </span><sup><a href="#ftnt4" id="ftnt_ref4">[4]</a></sup><span class="c0">, which visualises type inference through a web application. Users enter an expression in a custom expression language, submit a request to a server and are redirected to a page displaying an initial syntax tree, a final syntax tree and an overall substitution. By allowing users to enter their own expressions, students can explore how the systems work in different cases to gain an intuitive understanding of the concepts.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TypeTool&rsquo;s authors found in teaching the University of Porto&rsquo;s functional programming course that the tool was &ldquo;especially useful for students, because it helps to understand the type systems of the most common typed functional languages&rdquo; and that &ldquo;[presenting] the basis of type inference technology [...] significantly improved the way students deal with type errors because they understand the type system.&rdquo;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>However, TypeTool&rsquo;s parsing and type inference is done server-side so there is a delay between the user entering an expression and seeing the result. While short, a delay reduces the ease-of-use and may discourage users from trying many different expressions. Both delayed feedback and the lack of step-by-step explanations reduce learning quality (</span><sup><a href="#ftnt5" id="ftnt_ref5">[5]</a></sup><span>), particularly in the area of rule learning. </span><sup><a href="#ftnt6" id="ftnt_ref6">[6]</a></sup><span class="c0">&nbsp;showed that immediate explanatory feedback is most effective at learning how to apply rules in computer programming. It also lacks step-by-step explanations, and it is unclear whether it supports processing incorrectly-typed expressions.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">In addition, the tool is now inaccessible as the server hosting the application is no longer running and the source code has not been published.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Another tool in the area of visualising type systems was developed by </span><sup><a href="#ftnt7" id="ftnt_ref7">[7]</a></sup><span class="c0">. It is a visual functional programming system which shows types during function application for a subset of Standard ML, used to teach first year undergraduate students. However, this did not explicitly show the type inference process and as a desktop application rather than web app it is less accessible to lecturers and students. It also didn&rsquo;t support key functional language constructs such as function declarations and let bindings, and required significant explanation before using the tool to understand its output.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 478.20px; height: 299.47px;"><img alt="Screenshot of Yung and Michaelson&#39;s tool, taken from their paper" src="images/image3.png" style="width: 478.20px; height: 299.47px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>NiMo (</span><sup><a href="#ftnt8" id="ftnt_ref8">[8]</a></sup><span class="c0">) is a graphical programming language related to functional data processing which allows users to reason about the flow of data through a program. The types of data and processes can be inspected in NiMoToons, and type inference is performed over the network of components. However, larger expressions can become complicated and be difficult to interpret. While NiMo performs type inference internally it is not a key focus to the end-user, and as such does not explain its steps. Additionally, it is harder to relate back to more commonly used, textual functional languages like Haskell.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 576.24px; height: 192.40px;"><img alt="A diagram showing the types of some variables in NiMo, taken from their paper" src="images/image16.png" style="width: 576.24px; height: 192.40px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><sup><a href="#ftnt9" id="ftnt_ref9">[9]</a></sup><span class="c0">&nbsp;implemented a successful teaching tool, named TILC, for visualising lambda-calculus parse trees in order to help with teaching lambda-calculus to undergraduate students. They noted that to develop an intuitive understanding, students would benefit from experimenting with lambda-calculus and that &ldquo;a tool that deals with all these aspects in a friendly and graphical manner incentivises [experimentation]&rdquo;. TILC was successful, with the module organisers of &lsquo;programming paradigms&rsquo; at the Universitat de Girona having a &ldquo;good experience of using this tool in the course lectures and as a downloadable tool for students&rdquo;. The authors suggested extending TILC to show types and type inference would have pedagogical value.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">To summarise, types aid the construction of correct programs and type checking can detect issues in programs, either at compile-time or runtime. Type inference is a method often used alongside compile-time type checking to determine types in a program, an understanding of which could benefit computer scientists in writing and debugging programs. Some solutions exist which give students a better idea about types, however they either have significant limitations or do not explicitly cover type inference. In this report, we present an interactive web application for teaching type inference.</span></p><h1 class="c6" id="h.ebjyqi73zdyo"><span class="c19">Background</span></h1><h2 class="c15" id="h.odw4vku9eizz"><span class="c22">&lambda;-calculus</span></h2><p class="c1"><span>A &lambda;-calculus is a representation of computation. The first &lambda;-calculus set out by </span><sup><a href="#ftnt10" id="ftnt_ref10">[10]</a></sup><span class="c0">, often viewed as the canonical &lambda;-calculus, simply has variables, function abstraction and application.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">For this project, we will consider a calculus with five constructs to build expressions from. As a formal grammar:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.00px; height: 113.00px;"><img alt="" src="images/image18.png" style="width: 306.00px; height: 113.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; | c constant</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: latex-ify the above, move constant to top</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">For example, consider the expression `(&lambda;x. x) y`</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">It has variables `x` and `y`. Variables may be bound or free (unbound). Here `x` is bound as it is a parameter in the function abstraction, and `y` is free as there is nothing which binds it. This can be thought of in a similar way to how variables in most imperative programming languages have a scope where they are defined or undefined.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>The function abstraction mentioned is the `&lambda;x. x` part. This defines an anonymous function </span><span>which given</span><span class="c0">&nbsp;an argument (before the full stop) `x` simply returns (after the full stop) `x`, i.e. the identity function. A function to add three to an input might be written `&lambda;x. x + 3` (although many of the most fundamental &lambda;-calculi do not have such explicit notions of addition or numbers).</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Functions may be returned by other functions, which enables functions to have the appearance of taking multiple arguments. For example `&lambda;x. (&lambda;y. x)` can be viewed as a function which takes two arguments and returns the first one, even though really it is a function taking one argument which returns a function taking another argument for a result. Here explicit brackets have been given for clarity, but they aren&rsquo;t necessary. Additionally, sometimes multiple arguments like this are written together, so `&lambda;x. (&lambda;y. x)`, `&lambda;x. &lambda;y. x` and `&lambda;xy. x` all mean the same thing.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Finally, the function application is actually applying the function `&lambda;x. x` to the argument `y`. In &lambda;-calculus evaluation is performed via &beta;-reductions. In our example this could be done by substituting the argument `y` for parameter `x` in the body of the function `x`, resulting in `y`:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">This expression&rsquo;s construction can be represented as an abstract syntax tree:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: tree diagram of the expression</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">In addition to these three constructs, the `let` construct allows binding a value to a variable in an expression. For example `let x = 3 in x + x` binds `x` to the value `3` in `x + x`.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">A `con` construct is added to represent literal constants, such as numbers or booleans like `3` and `True`.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&lambda;-calculi have been extensively studied, often using formal inductive definitions. For example, the inductive definition for the set of free variables (`var`s not bound by function abstraction or let statements) is:</span></p><ul class="c14 lst-kix_n1icddiwhh1h-0 start"><li class="c1 c7 li-bullet-0"><span class="c0">`con`: $FV(c) = \varnothing$</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`var`: $FV(x) = { x }$</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`app`: $FV(e_1 e_2) = FV(e_1) \cup FV(e_2)$</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`abs`: $FV(\lambda x. e) = FV(e) - { x }$</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`let`: $FV(let x = e_1 in e_2) = FV(e_2) - { x }$</span></li></ul><p class="c1"><span class="c0">where e is an expression.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: fix latex of above</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Given these rules the set of free variables for any combination of these constructs can be determined. This can be demonstrated for our example expression `(&lambda;x. x) y`, which is shown in a tree structure below. More generally this is an example of how an inductive definition can tell us something about the entire program which is how some type inference algorithms can be viewed.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: tree diagram of the expression with the sets of free variables at each node.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Most real-world environments define a context which binds some variables by default to in-built values. For example Haskell&rsquo;s GHC primitives and Prelude includes basic variables like `[]` (the empty list) and `not` (a function which inverts booleans). These can be considered bound at the top level and removed from the set of free variables there.</span></p><h2 class="c15" id="h.w7vj0r89b86n"><span class="c22">The simply typed &lambda;-calculus</span></h2><p class="c1"><span>Typed </span><span class="c0">&lambda;-calculi extend the system with the concept of types.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>The simply typed &lambda;-calculus is one of the simplest typed &lambda;-calculi, and introduced by </span><sup><a href="#ftnt11" id="ftnt_ref11">[11]</a></sup><span class="c0">&nbsp;is often viewed as the canonical typed &lambda;-calculus. It has the `var`, `abs`, `app` and `con` constructs. Types in this system are either base types (often in the literature Greek letters &alpha;, &beta;, &gamma; are used, but these can be thought of similar to numbers, booleans, characters etc.) or functions between other types (such as `Int \rightarrow Bool`, or `Int \rightarrow (Bool \rightarrow Bool)`).</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>The syntax adds type annotations to `var`, `abs` and `con` constructs, for example (&lambda;x: Int. odd</span><span class="c31">Int \rightarrow Bool</span><span>&nbsp;</span><span>x</span><span class="c31">Int</span><span>) 3</span><span class="c31">Int</span><span class="c0">&nbsp;(although often for simplicity the types of `var` and `con` subexpressions, those in superscript, are left out).</span></p><h2 class="c15" id="h.gsouq2axz3k"><span class="c22">Hindley-Milner type system</span></h2><p class="c1"><span>Hindley-Milner (HM) is a typed &lambda;-calculus which allows for the types of programs to be inferred and no type annotations are required (</span><sup><a href="#ftnt12" id="ftnt_ref12">[12]</a></sup><sup><a href="#ftnt13" id="ftnt_ref13">[13]</a></sup><span>). It extends the simply typed &lambda;-calculus by adding `let` bindings and a richer type system that includes </span><span class="c11">type functions</span><span>&nbsp;and </span><span class="c11">polymorphism</span><span class="c0">.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Like expressions, types can be considered to be built from `var` variables and `app` function applications. Type variables are either base types like `Bool` and `Int` or type functions. Type functions can be applied, taking types as parameters to construct composite types.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 280.00px; height: 45.00px;"><img alt="" src="images/image11.png" style="width: 280.00px; height: 45.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">where C is a set of type functions such as `-&gt;`, `List` and `Maybe`.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: latexify the above, replace alpha with tn</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">For a type to be valid all functions must be fully applied, unlike expressions where the final expression may be a function. As with expressions, we can again assume a global context that binds the basics variables like `Bool` and `Int`. In Hindley&rsquo;s original paper only `-&gt;` was considered as a type function (i.e. $C = { \rightarrow }$), however here we explore several type functions that have been found useful in practice.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>The type function we&rsquo;ve already been using is `-&gt;` (the </span><span class="c11">function</span><span class="c0">&nbsp;type function). It takes two types as arguments and represents a function from the first type to the second. A function from `Int` to `Bool` is represented by `(-&gt;) Bool Int` in prefix notation, although would more commonly be written infix as `Bool \rightarrow Int`.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The function type function (`-&gt;`) should not be confused with the function type: an expression representing a function has a function type, and that function type is the function type function applied to arguments. For example `&lambda;x. x + 3` has a function type `Int \rightarrow Int`, which is the function type function `-&gt;` applied to arguments `Int` and `Int`.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The list type function is also very common, which given one type argument represents a list of those types. A list of booleans might be written `List Bool` or `[] Bool` in prefix notation, although often the list type is represented by wrapping the type argument in square brackets instead like `[Bool]`.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>`Maybe` is another type function commonly used in functional languages like Haskell. A `Maybe` represents the optional presence of something, similar to </span><span>Java&rsquo;s</span><span class="c0">&nbsp;`Optional` and C++&rsquo;s `std::optional`. Applied to a boolean type this may be written `Maybe Bool`, representing a wrapper around nothing or a boolean. In Java this would be represented with a generic as `Optional&lt;Boolean&gt;` and in C++ as `std::optional&lt;bool&gt;`.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">A similar common type function is `Either`, which takes two type arguments and represents a wrapper around either one of the types. For example, an either for a boolean or integer is written `Either Bool Int`.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Finally, tuples represent a defined-length sequence of elements of specific types. Tuple constructors are a set of type functions representing a cross product of their type arguments, named `,`, `,,`, `,,,` and so on for different element lengths. A 3-tuple holding a boolean, integer and integer can technically be written in prefix notation as `(,,) Bool Int Int` but instead generally tuples borrow mathematical syntax with parentheses and commas like `(Bool, Int, Int)`.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The set of types made from `var_t` and `app_t` are known as monotypes. For example, `Bool`, `Int`, `Bool \rightarrow Int`, and `Bool \rightarrow [(Bool, Int \rightarrow Maybe Bool)]` are all monotypes.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Adding zero or more for-all quantified type variables to monotypes forms polymorphic types or polytypes (called principal type schemes by Hindley). This can be thought of as the `abs` equivalent for types, written as `\forall a. \rho` where `\rho` is a polytype. This definition makes monotypes a special case of polytypes: monotypes are polytypes with zero for-all qualified type variables. We can therefore consider &lsquo;type&rsquo; to mean &lsquo;polytype&rsquo;. By convention, we use $t0, t1, t2, \dots$ for free type variables, and $a, b, c, \dots$ </span><span>for for</span><span class="c0">-all quantified type variables.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 174.00px; height: 51.00px;"><img alt="" src="images/image20.png" style="width: 174.00px; height: 51.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: latexify the above, but use rho instead of sigma and a instead of alpha</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Polytypes allow for parametric polymorphism, where a type may be parameterized by a for-all bound quantifier. This allows functions to accept different types as long as they meet certain constraints. For example the `length` function is polymorphic: it has the polytype `\forall a. [a] \rightarrow Int`, which accepts a list of any type and returns its length as an integer. It accepts different types such as `[Bool]` and `[Int]` as both of these meet the constraint of being a list.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Correctly inferring polymorphic types can be difficult, and in fact </span><sup><a href="#ftnt14" id="ftnt_ref14">[14]</a></sup><span class="c0">&nbsp;proved that doing so for System F, a type system similar to Hindley-Milner with fewer typing rule constraints, is undecidable. To prevent undecidability, HM avoids overusing polytypes, using only monotypes for `var`, `con`, `app` and `abs` expressions.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">To allow for some polymorphism, `let` expressions&rsquo; parameters are polymorphic in the `let` body. The process by which the monomorphic parameter type is turned into a polymorphic one is known as generalisation. The overall type of `let` expressions themselves are not generalised.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">This is the difference between:</span></p><ul class="c14 lst-kix_7lyu6nf8ijma-0 start"><li class="c1 c7 li-bullet-0"><span class="c0">`let i = (\lambda x \rightarrow x) in (i 3, i True)` type-checks, as i is generalised to the polytype `\forall a. a \rightarrow a` within the body `(i 3, i True)` so can be applied to both an `Int` and `Bool`</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`(\lambda i \rightarrow (i 3, i True)) (\lambda x. x)` does not type-check as the function abstraction `(\lambda x. x)` has the monotype `t0 \rightarrow t0`, and `t0` must take only one type in both tuple parts - it cannot be both an `Int` and a `Bool`.</span></li></ul><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Hindley-Milner is the basis for the type system of Standard ML (</span><sup><a href="#ftnt15" id="ftnt_ref15">[15]</a></sup><span>) (which OCaml and F# are related to) and was the basis of the type system in Haskell (</span><sup><a href="#ftnt16" id="ftnt_ref16">[16]</a></sup><span class="c0">). It has influenced the development of Rust and Swift, and more generally type inference is present in many more languages including Java, JavaScript and C++.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Haskell has since been extended with type-class constraints (</span><sup><a href="#ftnt17" id="ftnt_ref17">[17]</a></sup><span>), functional dependencies (</span><sup><a href="#ftnt18" id="ftnt_ref18">[18]</a></sup><span>), and generalised algebraic data types (GADTs) (</span><sup><a href="#ftnt19" id="ftnt_ref19">[19]</a></sup><span>). Haskell&rsquo;s inference engine was moved onto a new engine, OutsideIn(X), when GHC 7.2 was released November 2011 after </span><sup><a href="#ftnt20" id="ftnt_ref20">[20]</a></sup><span>&nbsp;proposed a solution to the issues with Hindley-Milner&rsquo;s poor performance on large programs and difficulty inferring expressions without principal types that arise with type-class constraints and GADTs. In doing this, Haskell stopped automatically generalising variables bound by `let` expressions after </span><sup><a href="#ftnt21" id="ftnt_ref21">[21]</a></sup><span class="c0">&nbsp;argued that generalising `let` bindings is complex in type inference engines other than HM and the feature was rarely used in practice, with the change only affecting 0.13% lines of the GHC core libraries. This change does however take it further away from performing HM-like type inference.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Rust&rsquo;s compiler, rustc, did at one time use a variant of HM for type inference. However, </span><sup><a href="#ftnt22" id="ftnt_ref22">[22]</a></sup><span>&nbsp;proposed a new scheme which was later implemented to simplify how the compiler reasoned about types. Similarly to Haskell&rsquo;s move to OutsideIn(X), the new type inference reduces flexibility in some edge cases, although practically this is rare. Both rustc and Rust&rsquo;s core libraries compiled under the new type inference scheme without changes. Later on, </span><sup><a href="#ftnt23" id="ftnt_ref23">[23]</a></sup><span class="c0">&nbsp;developed chalk, a library designed to be used in rustc to help implement Rust&rsquo;s generics. This library makes heavy use of unification, a key component of many HM type inference algorithms.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Apple&rsquo;s Swift heavily uses type inference. It is implemented using a &ldquo;constraint-based type checker that is reminiscent of the classical Hindley-Milner type inference algorithm&rdquo; (</span><sup><a href="#ftnt24" id="ftnt_ref24">[24]</a></sup><span class="c0">). Like other languages it extends HM with additional language features, such as more expressive polymorphic types with additional constraints. To adapt HM to a procedural language, and for improved performance and better error messages, Swift limits type inference to individual statements rather than entire programs.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">In addition to their own inference engines, many languages allow the programmer to add more type information through explicit type annotations or casting. This is particularly helpful where the programmer knows more than the type inference algorithm about the limits on how a part of a program will be used.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Java allows casting objects and TypeScript has its `as` type assertion operator. Programmers can use these sparingly (and often in combination with `instanceof` and `typeof` operators respectively) as an escape hatch to work around the type inference algorithm&rsquo;s limitations. In these situations statements may not be able to be type checked at compile-time so instead runtime checks are performed to maintain type safety.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Java allows casting an object to a subclass (</span><sup><a href="#ftnt25" id="ftnt_ref25">[25]</a></sup><span class="c0">). Runtime checks are performed, which throw a `ClassCastException` in case the object is not actually an instance of the subclass.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```java</span></p><p class="c1"><span class="c0">// Dog and Cat extend Animal</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Animal c1 = new Dog();</span></p><p class="c1"><span class="c0">Dog s1 = (Dog) c1; // okay</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Animal c2 = new Cat();</span></p><p class="c1"><span class="c0">Dog s2 = (Dog) c2; // throws ClassCastException at runtime</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TypeScript allows for casting compatible objects with its `as` operator, or overriding the compile-time type checking completely with a `@ts-ignore` comment. The following shows that some type-safe code is rejected by the TypeScript type checker, but with several possible workarounds.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">const a = Math.random() &lt; 0.5 ? &#39;cs310&#39; : 310; // has type &quot;cs310&quot; | 310</span></p><p class="c1"><span class="c0">const b = a + a; // throws a type error, but b could have type &quot;cs310cs310&quot; | 620</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">const c = a == &#39;cs141&#39; ? a + a : a + a; // okay, has type number | string</span></p><p class="c1"><span class="c0">const d = a as any + a; // okay, has type any</span></p><p class="c1"><span class="c0">const e = a as any + a as &#39;cs310cs310&#39; | 620 // okay, has type &quot;cs310cs310&quot; | 620</span></p><p class="c1"><span class="c0">// @ts-ignore</span></p><p class="c1"><span class="c0">const f: &#39;cs310cs310&#39; | 620 = a + a; // okay, has type &quot;cs310cs310&quot; | 620</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: (maybe?) Add section on TypeScript/Elm?</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c20"><a class="c29" href="https://www.google.com/url?q=https://aaltodoc.aalto.fi/bitstream/handle/123456789/42719/master_Mikkonen_Juuso_2020.pdf&amp;sa=D&amp;source=editors&amp;ust=1618782946561000&amp;usg=AOvVaw0p8mejXf8JbKrtPGtEOa53">https://aaltodoc.aalto.fi/bitstream/handle/123456789/42719/master_Mikkonen_Juuso_2020.pdf</a></span></p><p class="c1"><span class="c0">Talks about statically typed languages in JavaScript-land. Mentions things like TypeScript don&rsquo;t use HM because JS has a lot of structural typing (i.e. if objects have the right properties it&rsquo;s fine to call methods that depend on that interface) and subtyping.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">While real-world languages don&rsquo;t work exactly like HM, for the purposes of the teaching tool HM gives a good representation of how type inference works to students. HM avoids being too complex to understand, and is still related to how languages commonly used in practice perform type inference.</span></p><h2 class="c15" id="h.admfqf7bhkct"><span class="c22">Hindley-Milner type inference</span></h2><p class="c1"><span>Various algorithms are available to infer types in Hindley-Milner such as Algorithm W by </span><sup><a href="#ftnt26" id="ftnt_ref26">[26]</a></sup><span>&nbsp;and Algorithm M by </span><sup><a href="#ftnt27" id="ftnt_ref27">[27]</a></sup><span>. Algorithm W takes a bottom-up approach, attempting to infer the types of subexpressions up the abstract syntax tree, while Algorithm M takes a top-down approach, inferring types down the tree. Algorithm W&rsquo; is a minor extension to Algorithm W, by </span><sup><a href="#ftnt28" id="ftnt_ref28">[28]</a></sup><span class="c0">&nbsp;which can improve the quality of type errors raised.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Substitutions are a key concept from logic used by the algorithms. These are maps from variables to terms. When applied to an expression, the variables are substituted with their corresponding terms. In the case of type inference, the variables are type variables, the terms are monotypes and expressions are types.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: fix this latex</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Substitutions are represented with curly braces, with each entry separated by a comma and the variables and terms separated with an arrow. For example, ${ t0 \mapsto t1, t2 \mapsto (Int, Bool) }$ would replace $t0$ with $t1$, and replace $t2$ with $(Int, Bool)$. Applied to the type $t0 \rightarrow t1 \rightarrow t2$ results in $t1 \rightarrow t1 \rightarrow (Int, Bool)$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">When applying substitutions replacements are performed simultaneously, meaning each variable in the expression may be mapped at most once. For example the substitution $S = { t0 \mapsto t1, t1 \mapsto t2 }$ applied once to the expression $t0$, as $S(t0)$ results in $t1$, not $t2$. Applying the substitution twice, $S(S(t0))$ would result in $t2$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Any number of substitutions may be applied to expressions. For example, given $S_1 = { t0 \mapsto t2, t1 \mapsto t3 }$ and $S_2 = { t0 \mapsto t1 }$, we may apply both to an expression $t0$. Note that this is not commutative, $S_1(S_2(t0)) = t3$ while $S_2(S_1(t0)) = t2$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Substitutions may be combined to have the same effect as applying them in order to an expression $E$. For example, with $S_1 = { t0 \mapsto t2, t1 \mapsto t3 }$ and $S_2 = { t0 \mapsto t1 }$ again, $combine(S_1, S_2)(\rho) = S_1(S_2(\rho)) = { t0 \mapsto t3, t1 \mapsto t3 }(\rho)$. As application is not commutative, the order substitutions are combined in matters, i.e. $combine(S_1, S_2)$ does not necessarily equal $combine(S_2, S_1)$. Combining substitutions is however associative, as $combine(S_1, combine(S_2, S_3))(\rho) = S_1(S_2(S_3(\rho))) = combine(combine(S_1, S_2), S_3)(\rho)$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">A substitution is said to unify two expressions if when applied to both it results in equal expressions. For example, ${ t0 \mapsto Int, t1 \mapsto Bool }$ unifies $(t0, Bool)$ and $(Int, t1)$, as when the substitution is applied to either expression the result is $(Int, Bool)$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Unification is the process of finding unifying substitutions given two expressions, or reporting no such substitution exists. </span><sup><a href="#ftnt29" id="ftnt_ref29">[29]</a></sup><span>&nbsp;presents a simple algorithm for unification, and </span><sup><a href="#ftnt30" id="ftnt_ref30">[30]</a></sup><span>&nbsp;and </span><sup><a href="#ftnt31" id="ftnt_ref31">[31]</a></sup><span class="c0">&nbsp;set out linear time unification algorithms.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">In the type inference algorithms W, W&rsquo; and M, unification is applied to pairs of monotypes. This results in substitutions which effectively combine the various type constraints giving us a final type.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">For example, take an expression satisfying two type constraints: it matches the monotype $[Bool] \rightarrow t0$ and it matches with the monotype $[t1] \rightarrow t1$. These constraints might arise in evaluating the type of `head [True]`. The first constraint is from knowing `[True]` is a $[Bool]$ so the function should accept a $[Bool]$. The second constraint is based on the known definition of `head` in the global context. Unification can find the unifying substitution ${ t0 \mapsto Bool, t1 \mapsto Bool }$, giving the overall type $[Bool] \rightarrow Bool$. We can then see the resultant type of `head [True]` is $Bool$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">If at any point unification is not possible, the type constraints must be incompatible and so a type error is raised. For example, there is no unifying substitution for $Int \rightarrow t0$ and $Bool \rightarrow t1$ as one is a function accepting an $Int$ and the other accepts a $Bool$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">For practical purposes, in type inference algorithms we require unifying substitutions to be finite as infinite types are difficult to represent and reason about. For example `x` in `&lambda;x. x x` needs to be a function that accepts itself. Initially assuming `x` has type $t0 \rightarrow t1$ and knowing it should accept itself, it also has type $(t0 \rightarrow t1) \rightarrow t1$. It also must accept that, so has type $((t0 \rightarrow t1) \rightarrow t1) \rightarrow t1$, $(((t0 \rightarrow t1) \rightarrow t1) \rightarrow t1) \rightarrow t1$, and so on. This is an infinite type and is not allowed by HM. Note that this does not exclude functions from HM which do accept themselves, such as the identity function `id` with its finite type $\forall a. a \rightarrow a$, as long as they themselves have finite types.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Detecting infinite types in unification is done by checking whether the types are not equal and one of the types occurs in another. This is known as the occurs check. In the previous example `&lambda;x. x x` we might try to unify $t0 \rightarrow t1$ with $t0$. $t0$ occurs in $t0 \rightarrow t1$ so there is no finite unifying substitution (an infinite unifying substitution is ${ t0 \mapsto ((((t0 \rightarrow t1) \rightarrow t1) \rightarrow infinite t1s \dots) \rightarrow t1) }$). The occurs check failing necessarily means we have an infinite type: the type contains itself.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Inferring types is done in a typing context. Languages often have a global context with built-in functions and their types pre-defined, such as Haskell&rsquo;s Prelude and JavaScript&rsquo;s global objects.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Typing contexts can be seen as maps from variable names to their corresponding types, and are represented with the symbol $\Gamma$. For example a context with some common functions may be written $\Gamma = { not: Bool \rightarrow Bool, odd: Int \rightarrow Bool, id: \forall a. a \rightarrow a }$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Constructs that bind variables like `let` and `abs` add entries to a local context for these additional bindings, used in the construct bodies. For example, in `let x = 3 in odd x` the binding $x: Int$ may be added to the context used to perform type inference on the body subexpression `odd x`. Similarly in `\x \rightarrow not x` the binding $x: t0$ may be added to the context for inferring the type of the function body `not x`. Adding a binding to the context is represented by a $+$, so given $\Gamma = { x: Bool }$ then $\Gamma + y: Int$ is ${ x: Bool, y: Int }$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Applying a substitution to a context is to apply the substitution to every type in the context, or effectively every &lsquo;value&rsquo; in the key-value map. For example, applying the substitution $S = { t0 \mapsto t1, t2 \mapsto Int }$ to the context $\Gamma = { x: t0, y: t1, z: t2 }$, results in a new context $S(\Gamma) = { x: t1, y: t1, z: Int }$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Some types are considered more general than others. A type $\rho_a$ is more general than a type $\rho_b$ if there exists a substitution from $\rho_a$ to $\rho_b$ whose variables are for-all quantified in $\rho_a$. This is denoted by $\sqsubseteq$, for example $\forall a. a \rightarrow a$ is more general than $Int \rightarrow Int$ by the substitution ${ a \mapsto Int }$, written $\forall a. a \rightarrow a \sqsubseteq Int \rightarrow Int$. Substitutions may (and often do) substitute quantified type variables with free type variables like $t0$ and $t1$, rather than concrete types like $Int$ and $Bool$. As an example, $\forall a \forall b. (a \rightarrow b) \rightarrow [a] \rightarrow [b] \subseteq \forall a. (a \rightarrow Bool) \rightarrow [a] \rightarrow [Bool] \subseteq (t0 \rightarrow Bool) \rightarrow [t0] \rightarrow [Bool]$, following substitutions ${ b: Bool }$ and ${ a: t0 }$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">For any type $\rho \subseteq \rho$, as the substitution may be empty. A type is strictly less general ($\sqsubset$) than another if and only if the substitution is non-empty. This means a strictly less general type must have at least one fewer quantified variables as one for-all quantified variable must be substituted away.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: (maybe) partial order diagram of some of $\forall a \forall b. (a \rightarrow b) \rightarrow [a] \rightarrow [b]$&rsquo;s partial and full instantiations.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>An expression with a type $\rho_1$ more general than another type $\rho_2$ can be considered to have the less general type $\rho_2$. This means if an expression with type $\rho_2$ is needed, providing an expression with type $\rho_1$ will type-check if and only if $\rho_1 </span><span>\sqsubseteq</span><span class="c0">&nbsp;\rho_2$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The process of giving an expression a less general type is known as instantiation of a type. For example, the type of `id`, $\forall a. a \rightarrow a$, can be instantiated as all of $Int \rightarrow Int$, $Bool \rightarrow Bool$, $t0 \rightarrow t0$ or even $([t0] \rightarrow (Int, Bool)) \rightarrow ([t0] \rightarrow (Int, Bool))$ and more.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The &lsquo;opposite&rsquo; to instantiation is generalisation, where an expression with a certain type can be considered to have a more general type, adding a for-all quantification of a variable. This is allowed where the type variable is not free in any of the types in the context. Not being free in the context means the type variable does not appear unbound anywhere except in the type being generalised itself, so it does not have any other type constraints. Being free of any type constraints, it may be any type and therefore for-all quantified.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Given a type $t0 \rightarrow t1 \rightarrow t2 \rightarrow t3$ and a context ${ x : t1, y : [t2] \rightarrow Int, z: \forall t3. t3 }$ we may generalise to $\forall t0 \forall t3. t0 \rightarrow t1 \rightarrow t2 \rightarrow t3$. $t0$ is not in any of the types in the context, and $t3$ is only found bound as a for-all quantified variable. Therefore both of these may be for-all quantified. Both $t1$ and $t2$ are free in the context, so may not be generalised. (Note we&rsquo;re disregarding our convention of using $a, b, c, \dots$ </span><span>for for</span><span class="c0">-all quantified variables here, to be strict to the typing rules. Renaming the type variables with &alpha;-conversions could be done after generalisation to maintain the type variable naming conventions.) Given a context and type, the function $generalise$ returns the fully generalized type possible in that context.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Our five key syntax rules plus instatitation and generalisation give us nine typing rules. Many presentations of Hindley-Milner do not include literal constants in their syntax, or do not explicitly type them given their triviality. Here we give them for completeness.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 303.00px; height: 420.00px;"><img alt="" src="images/image7.png" style="width: 303.00px; height: 420.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">---------- [Const_i]</span></p><p class="c1"><span class="c0">c_i : Int</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">-------------- [Const_c]</span></p><p class="c1"><span class="c0">c_c : Char</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">-------------- [Const_b]</span></p><p class="c1"><span class="c0">c_b : Bool</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: latexify the above, replacing sigma with rho</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">These typing rules can be used to deduce and prove the types of expressions. For example, the expression `not True` in a context $\Gamma = { not: Bool \rightarrow Bool }$:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">$\Gamma \vdash not : Bool \rightarrow Bool [Var]$</span></p><p class="c1"><span class="c0">$\vdash True : Bool [Const_b]$</span></p><p class="c1"><span class="c0">$\Gamma \vdash not True : Bool [App]$</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Despite this, the typing rules themselves aren&rsquo;t an algorithm as they do not specify an order to be applied in. While only one syntax rule can apply to a subexpression, it may be unclear when to apply instantiation and generalisation. Arbitrarily applying rules does not necessarily converge to a solution, as generalisation and instantiation can both continue infinitely. For example repeatedly applying instantiation and generalisation on `id` with $\Gamma = { id: \forall a. a \rightarrow a }$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">$\Gamma \vdash id : \forall a. a \rightarrow a [Var]$</span></p><p class="c1"><span class="c0">$\Gamma \vdash id : [t0] \rightarrow [t0] [Inst] (a/[t0])$</span></p><p class="c1"><span class="c0">$\Gamma \vdash id : \forall b. [b] \rightarrow [b] [Gen]$</span></p><p class="c1"><span class="c0">$\Gamma \vdash id : [[t1]] \rightarrow [[t1]] [Inst] (b/[t1])$</span></p><p class="c1"><span class="c0">$\Gamma \vdash id : \forall c. [[c]] \rightarrow [[c]] [Gen]$</span></p><p class="c1"><span class="c0">$\Gamma \vdash id : [[[t2]]] \rightarrow [[[t2]]] [Inst] (c/[t2])$</span></p><p class="c1"><span class="c0">$\dots$</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The type inference algorithms W, W&rsquo; and M effectively are methods to select typing rules to determine a type for the expression, or detect the expression is incorrectly typed. While they don&rsquo;t apply the typing rules directly, they are close and their respective authors prove they give equivalent results and can be implemented directly.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The algorithms are applied to abstract syntax trees, which represent the expressions in a structured way. For example, an abstract syntax tree for `let y = (\x \rightarrow (odd x)) 3 in not y` may be visualised as:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: tree diagram of expression</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The type inference algorithms are therefore tree traversal algorithms. Generally, they call themselves recursively on subtrees to process subexpressions, and then combine these results to determine a final type (the type of the root node).</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Algorithm W is often seen as </span><span class="c11">the</span><span class="c0">&nbsp;Hindley-Milner type inference algorithm. Given a context and an expression represented as an abstract syntax tree, W returns a substitution and a monotype.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>The purpose of returning the type is obvious, but the purpose of the substitution is less clear. The substitution is a representation of constraints on type variables that have arisen from performing type inference on the expression. For example, given a context ${ f: t0, not: Bool \rightarrow Bool }$ and an expression `not (f 3)` we might return the type $Bool$ and the substitution ${ t0 \mapsto Int \rightarrow Bool }$. This substitution is important because </span><span>if `f</span><span>` </span><span>or the</span><span class="c0">&nbsp;type variable $t0$ are used elsewhere in the same expression we need to type-check those occurrences for consistency with this usage. In a wider expression such as `[not (f 3), f True]` the substitution from our first subexpression tells us type $t0$ is $Int \rightarrow Bool$. When examining the application of the second `f`, we find its type from the context which is $t0$, or equivalently now $Int \rightarrow Bool$. We can then raise a type error as we have applied it on a $Bool$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The algorithm is set out below, for each of the five language constructs. There is a case for each type of node in the abstract syntax tree, so the rule applied at each point is deterministic and easily-chosen based on the node type. Explanations of the more complex cases are given below the algorithm.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 592.00px; height: 330.00px;"><img alt="" src="images/image1.png" style="width: 592.00px; height: 330.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: latexify the above (taken from Lee), replace () with constants, replace TypeEnv with Context, replace Expr with Expression, replace Subst with Substitution, replace Type with MonoType, replace Clos with generalise, add brackets around applying substitutions, add explicit combines, number the statements, replace id with {}, flip ordering of abs and app, replace var rule with let S_1 = { a \mapsto t0, b \mapsto t1, &hellip; }, new t0, t1, &hellip; in (id, S_1\tau) where \Gamma(x) = \forall a \forall b &hellip; \tau</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The notation $new tn$ specifies that the type variable $tn$ is new (or &lsquo;fresh&rsquo;), so its name has not been used before. Using globally unique type variables avoids reuse which may incorrectly mix constraints between different types. Most implementations use a global counter, incremented each time a new type variable is needed with names like $t0, t1, t2, \dots$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The general structure of Algorithm W is to recursively call itself on subexpressions, until the subexpressions are simple leaf nodes. At this point, constant nodes have their assigned type and variable nodes have their type retrieved from the context. The subexpression types are passed back up, where their substitutions are either combined or fed into inferring other subexpressions, and a resultant type is returned.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Case (4app) for function application infers the types of the two subexpressions. It first infers the left one, $e_1$, then applies the resultant substitution to the context before inferring the right subexpression, $e_2$. This ensures constraints arising from the $e_1$ are considered when inferring the second subexpression, so if $e_1$ and $e_2$ have conflicting constraints this is detected and a type error is raised. However, this does introduce a left-to-right bias where the type error is raised in the right subexpression if a conflict is found.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Given we know $e_1$ is a function that should accept $e_2$&rsquo;s type, $\tau_2$, we should be able to unify $\tau_2 \rightarrow tn$ (a function accepting $\tau_2$ and returning $tn$ i.e. anything) with the function type $\tau_1$. We apply the substitution $S_2$ to $\tau_1$ when doing this to ensure no constraints have arisen in inferring $e_2$ that would prevent this unification. Finding a unifying substitution confirms the function application is valid, and we are able to determine the return type (and thus the overall type of this expression) by applying the unifying substitution to the type variable $tn$ used as the return type. If no unifying substitution can be found, the function application is invalid (as the argument type $\tau_2$ cannot be substituted to reach an accepted type for the function&rsquo;s type $\tau_1$) and a type error is raised. Invalid function application (4app) and undefined variables (1var) are the only possible sources of type errors from Algorithm W.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">To illustrate, consider `odd 3` in the context $\Gamma = { odd: Int \rightarrow Bool }$. We find the types of `odd` and `3` as $Int \rightarrow Bool$ and $Int$ respectively, unify $Int \rightarrow Bool$ with $Int \rightarrow t0$ to get the substitution $S_3 = { t0 \mapsto Bool }$ and return the overall type $S_3(tn) = { t0 \mapsto Bool }t0 = Bool$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Also consider `odd x` in the context $\Gamma = { odd: Int \rightarrow Bool, x: t0 }$. Here we find the types of `odd` and `x` as $Int \rightarrow Bool$ and $t0$ respectively, unify $Int \rightarrow Bool$ with $t0 \rightarrow t1$ to get the substitution $S_3 = { t0 \mapsto Int, t1 \mapsto Bool }$ and return the overall type $S_3(tn) = { t0 \mapsto Int, t1 \mapsto Bool }t1 = Bool$. In this we also return the substitution ${ t0: Int, t1: Bool }$, constraining the external type $t0$ to an $Int$. Given we created $t1$ as a new type variable, it won&rsquo;t be found elsewhere so does not need to be considered in other expressions so the substitution ${ t0 \mapsto Int }$ could equivalently have been returned.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Case (3abs) for function abstraction first infers the type of the function body expression, $e$, by calling W recursively. It passes the current context with an additional binding for the function parameter $x$, assigned to a new type variable with no constraints. This subcall to W for the function body returns the substitution $S_1$ and type $\tau_1$. Finally, the substitution $S_1$ and type $S_1(tn \rightarrow \tau_1)$ is returned as the final result for the function abstraction. The type arises from the fact that the function abstraction takes the parameter with the new type $tn$ and returns the type of the body, $\tau_1$. We apply the substitution $S_1$ to it to reflect any constraints on the function parameter picked up in the function body.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">For an example examine calling W on `\x \rightarrow odd x` with $\Gamma = { odd: Int \rightarrow Bool }$. The subcall to W calls $W(\Gamma + x: t0, odd x)$ which returns $(S_1, \tau_1) = ({ t0: Int }, Bool)$. Then $(S_1, S_1(tn \rightarrow \tau_1)) = ({ t0 \mapsto Int }, { t0 \mapsto Int }(t0 \rightarrow Bool)) = ({ t0 \mapsto Int }, Int \rightarrow Bool)$ is returned as the result.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Case (5let) for let statements first infers the type $\tau_1$ of the parameter definition, $e_1$. The parameter type $\tau_1$ is then generalised with respect to the context to allow for polymorphism as per HM&rsquo;s type system, before being added to the context as a binding and used to infer the </span><span>let</span><span>&nbsp;body $e_2$. The substitutions $S_1$ and $S_2$ are then combined to collect the constraints, and are returned with the </span><span>let</span><span class="c0">&nbsp;body&rsquo;s type $\tau_2$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Algorithm W&rsquo; is a slightly altered variant of Algorithm W, only changing rule (4app) for function application to avoid left-to-right bias.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 469.40px; height: 258.57px;"><img alt="" src="images/image14.png" style="width: 469.40px; height: 258.57px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: write out algorithm in Lee format for W&rsquo;, 1-index, replace S&rsquo; with S_3, V with S_4</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Algorithm W&rsquo; performs substitution unification, introduced in the same paper as W&rsquo;. Like type unification, substitution unification attempts to find a unifying substitution to unify two values. Unlike type unification, substitution unification attempts to make two substitutions, not types, equal. It returns a unifying substitution, which when combined with either substitution gives the same result, i.e. $combine(unify(S_1, S_2), S_1) = combine(unify(S_1, S_2), S_2)$. Both type and substitution unification is commutative and associative, and may fail if no such substitution exists.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">If substitutions share no type variables, finding a unifying substitution can be done by simply combining the substitutions. For example, $unify({ t0 \mapsto Int }, { t1 \mapsto Bool }) = combine({ t0 \mapsto Int }, { t1 \mapsto Bool }) = { t0 \mapsto Int, t1 \mapsto Bool }$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">However, substitution unification generally is different to substitution combination. Combination only simulates the effect of applying consecutive substitutions, so is not concerned with unifying substitution types or maintaining constraints. For example, given $S_1 = { t0 \mapsto t1 \rightarrow Bool }$ and $S_2 = { t0 \mapsto Int \rightarrow t2 }$, then $S_3 = unify(S_1, S_2) = { t1 \mapsto Int, t2 \mapsto Bool }$, which is not the same as combining the substitutions. Note the resultant unifying substitution may have a non-empty domain disjoint from both the given substitutions, as in this example. We can see that $combine(S_3, S_1) = combine(S_3, S_2) = { t0 \mapsto Int \rightarrow Bool, t1 \mapsto Int, t2 \mapsto Bool }$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Having defined substitution unification, case (4app) in W&rsquo; is fairly straightforward. It independently infers the two subexpressions $e_1$ and $e_2$, rather than applying $e_1$&rsquo;s substitution $S_1$ to the context before inferring $e_2$ as in W. The substitutions are then unified and then applied to both subexpression types, ensuring all constraints are applied to both types. The function type and the argument to new type can then be unified in the same way as W.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Algorithm M is a top-down approach to type inference. Implemented as part of an early ML compiler by </span><sup><a href="#ftnt32" id="ftnt_ref32">[32]</a></sup><span>, it was known as a &lsquo;folklore&rsquo; algorithm until </span><sup><a href="#ftnt33" id="ftnt_ref33">[33]</a></sup><span class="c0">&nbsp;formalised it as in the figure below.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Given a context, expression and type it returns a substitution. When compared to W&rsquo;s signature, this effectively moves the type from the output of W to the input of M. The input type now represents an expected type for the expression, to be checked and then refined by returning a substitution. Types are refined as they progress down the tree (hence top-down), and if they are found to be incompatible at any point a type error is raised. In some cases this can lead to more specific error messages as type errors are generally raised lower down the tree, rather than at potentially more complex function application expressions as in W. More specific error messages are more useful for developers to identify where the bugs are in their programs.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">M is initially started at the root node with a new type, i.e. $M(\Gamma, e, tn), new tn$, and the final type can be determined by applying the returned substitution to $tn$. In this way both type inference algorithms can be wrapped to have the signature $Context \times Expression \rightarrow Type$ which would be naturally expected from type inference algorithms.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 297.33px;"><img alt="" src="images/image4.png" style="width: 601.70px; height: 297.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: latexify the above (taken from Lee), make replacements as per W alg, replace rho with tau_e</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">M has some similarities to W, however where W applies unification in function application, M instead pushes this down the tree and performs unification in the leaf nodes and function abstraction.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">In rules (1con) and (2var) for constant and variable expressions, we are given an expected type $\tau_e$ and are verifying it can unify with the literal constant&rsquo;s type or the type from the context respectively. Unifying in this way returns the type in the substitution, for example $M({}, 3, t0) = unify(Int, t0) = { t0: Int }$ and $M({ odd: Int \rightarrow Bool }, odd, t0 \rightarrow t1) = unify(Int \rightarrow Bool, t0 \rightarrow t1) = { t0: Int, t1: Bool }$, which is passed back up the tree.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Rule (4app) shows function application in M has no unification step. Instead, M is simply called recursively for each expression. The first expression, $e_1$, is expected to be a function taking a new type variable $tn$ and returning the expected type $\tau_e$ for the overall application. The second expression should have the argument type for the function, $tn$, after applying substitution $S_1$ to collect type constraints.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">For example, consider `odd 3` in the context $\Gamma = { odd: Int \rightarrow Bool }$ with expected type $t0$. We call M with the expected type $t1 \rightarrow t0$ on `odd` to get the substitution $S_1 = { t1: Int, t0: Bool }$. We then call M with the expected type $S_1(t1) = Int$ on `3`, which is validated and returns an empty substitution $S_2 = {}$. Finally, we return the combined substitution ${ t1: Int, t0: Bool }$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">In rule (3abs) for function abstraction, we verify the expected type unifies with a new function type. This gives a substitution mapping the variables $t1$ and $t2$ to the expected function types, if any. This is applied to the context, along with adding the parameter $x$&rsquo;s type as $t1$. We then use M to infer the type of the function body, expecting it to have the unified return type $t2$. We return the combined substitution from both parts.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">For an example we look at applying M on `\x \rightarrow odd x` with $\Gamma = { odd: Int \rightarrow Bool }$ and expected type $t0$. We first unify $t0$ with the new type $t1 \rightarrow t2$, resulting in $S_1 = { t0: t1 \rightarrow t2 }$. We then make the recursive call to M with the function body `odd x`, context ${ odd: Int \rightarrow Bool, x: t1 }$ and expected type $t2$. This results in the substitution $S_2 = { t1: Int, t2: Bool }$, which we combine with $S_1$ to get $combine(S_2, S_1) = { t0: Int \rightarrow Bool, t1: Int, t2: Bool }$. As in W&rsquo;s function application, the new type variables will be unused outside of this expression so we can equivalently exclude $t1$ and $t2$ from the substitution.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Finally, let expressions infer the type of their parameter $e_1$ with a new type, then infer the type of their body $e_2$ expecting it to have the overall expected type $\tau_e$. Similarly to function abstraction, the substitution from the parameter is passed when inferring the body, and combined with the body&rsquo;s substitution to give an overall result.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">These type inference algorithms do have limitations. They all sometimes produce poor type error messages; Algorithm W often detects errors late, highlighting too large of a subexpression to be useful and Algorithm M often detects too specific of a term without context as to what original definition it violates. Algorithm W has the left-to-right bias which Algorithm W&rsquo; attempts to correct for, however this can sometimes exacerbate the problem with highlighting large subexpressions. Poor error messages make it difficult for the programmer to understand how to fix the problem.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>To improve error messaging, hybrid or constraint-based algorithms along with heuristics are often used in practice to provide more informative error messages. Reducing the size of the amount inferred at once can help make errors more precise. For example, Apple&rsquo;s Swift uses a bi-directional type inference algorithm on single statements (</span><sup><a href="#ftnt34" id="ftnt_ref34">[34]</a></sup><span class="c0">).</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Additionally, despite not being required in all languages, explicit type annotations are often used to help identify errors earlier at locations which are easier to interpret (</span><sup><a href="#ftnt35" id="ftnt_ref35">[35]</a></sup><span>). This is especially common for function definitions or program entry points. This also effectively splits up the program into smaller parts which can be inferred against separately, improving performance and making type errors more precise. In some cases, type inference algorithms struggle with (directly or indirectly) recursively defined functions and type annotations can help define these types. Finally, changing a rigidly-typed interface also highlights potential breaking changes to libraries or helper functions. In this way type annotations act as documentation to future programmers using the code. Manually specified, more specific types may be an improvement over automatically inferred types as sometimes the most general type as worked out by a type inference algorithm may not clearly convey the intent of the programmer.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: (maybe?) Add a section on type errors. Resources:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c20"><a class="c29" href="https://www.google.com/url?q=https://www.researchgate.net/profile/Jurriaan_Hage/publication/221241370_Scripting_the_Type_Inference_Process/links/02e7e51a37f9233c65000000.pdf&amp;sa=D&amp;source=editors&amp;ust=1618782946576000&amp;usg=AOvVaw3B2YO8AJpXYrrwXCYI4dJU">https://www.researchgate.net/profile/Jurriaan_Hage/publication/221241370_Scripting_the_Type_Inference_Process/links/02e7e51a37f9233c65000000.pdf</a></span></p><p class="c1"><span class="c0">Improving type error messages</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c20"><a class="c29" href="https://www.google.com/url?q=https://dspace.library.uu.nl/bitstream/handle/1874/7297/full.pdf?sequence%3D8&amp;sa=D&amp;source=editors&amp;ust=1618782946577000&amp;usg=AOvVaw01oH726QJBc0U0tVbpm7Qp">https://dspace.library.uu.nl/bitstream/handle/1874/7297/full.pdf?sequence=8</a></span></p><p class="c1"><span class="c0">Top quality type error messages</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c20"><a class="c29" href="https://www.google.com/url?q=https://manu.sridharan.net/files/mycroft-preprint.pdf&amp;sa=D&amp;source=editors&amp;ust=1618782946578000&amp;usg=AOvVaw04PwxIm01MiXRfB0bsQu2H">https://manu.sridharan.net/files/mycroft-preprint.pdf</a></span></p><p class="c1"><span class="c0">A Practical Framework for Type Inference Error Explanation</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c20"><a class="c29" href="https://www.google.com/url?q=http://citeseerx.ist.psu.edu/viewdoc/download?doi%3D10.1.1.110.5050%26rep%3Drep1%26type%3Dpdf&amp;sa=D&amp;source=editors&amp;ust=1618782946579000&amp;usg=AOvVaw1anHXkG9d_Wze1muE3SWJG">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.110.5050&amp;rep=rep1&amp;type=pdf</a></span></p><p class="c1"><span class="c0">PhD thesis which talks about hindley milner and type inference errors a lot</span></p><h1 class="c6" id="h.7ggvdxb04tzm"><span class="c19">Design</span></h1><p class="c1"><span class="c0">The design of the teaching tool is split into two parts, working backwards from the end product in mind: designing the user interface and experience, and designing the architecture to support that.</span></p><h2 class="c15" id="h.dr046u473e01"><span class="c22">User interface and experience</span></h2><p class="c1"><span class="c0">Before designing the new teaching tool, we explore the existing available resources to see what works well, and what is missing. The current resources for learning about type inference can be generally categorised into three categories: programming language documentation, formal resources and informal resources. These resources were found by examining the pages returned by the first 5 pages of Google search on the query &lsquo;type inference&rsquo;. The following is a summary of what was found from reading these resources with the aim of determining their strengths and weaknesses.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Programming language documentation are pages written to explain how type inference works in a specific language, as part of that language&rsquo;s official documentation. For example, TypeScript, Java and Golang all have official websites where they discuss how type inference works in their language.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Formal resources include university lecture notes, papers on type inference or encyclopedias. The first two are often in PDF format or on archiving websites. Wikipedia and WikiWikiWeb are examples of the latter (while encyclopedias summarise the subject they are generally written formally, with a lot of mathematical notation hence fall in this category).</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Informal resources include personal blog posts and online talk recordings. These are generally written by developers interested in programming language design or compiler development.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Each category of resource covers different aspects of type inference.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Formal resources generally cover the most generic and widely-applicable concepts in a succinct manner. They usually present type inference in the context of the Hindley-Milner system, or a related functional language such as ML or OCaml. Formal resources usually detail how type inference algorithms (usually algorithm W) go about determining types, and the specific rules of the type system they operate in. It is rare for them to discuss how type errors are treated or give examples of error cases.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Programming language documentation </span><span>covers</span><span class="c0">&nbsp;type inference in the context of a specific language, with all results inspected giving code examples along with text explaining what the code is doing. Generally this documentation explains the features of type inference present in the language, rather than the wider concepts, although does so in a directly-applicable way. Some languages also explain language-specific concepts in detail, such as how type inference works with Java&rsquo;s generics or TypeScript&rsquo;s functions. They are also tailored to how languages are used, with Java&rsquo;s documentation exploring how type inference is applied in object-oriented programming and TypeScript giving examples of type inference with web APIs. They often do not discuss how the type inference algorithms determine the types, but rather just what the types are and roughly the rules of the type system. However, they do usually give sufficient examples to understand the type system, with languages such as TypeScript, Java and Scala including error cases and explanations on how to fix the type errors. These error examples are particularly helpful as they show how a programmer might go about debugging and fixing type errors found in their program.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Informal resources generally </span><span>discusses</span><span class="c0">&nbsp;personal reflections on what the author has learnt about type inference or they heavily focus on type inference&rsquo;s application within a specific language the author is familiar with. These are generally the least widely-applicable, and often only cover a small part of a single programming language, however do so in great detail and often giving practical advice about work related to their subject matter.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Resources also differ in accessibility: how easy it is for a user to read, understand and apply their content.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Programming language documentation and informal resources both are generally aimed at a more clearly targeted audience, usually programmers using a specific language. They are written in simpler language and use significantly less notation than formal resources which makes them easier reading. Their use of examples makes concepts clearer, and many of them have a level of interactivity which allows readers to try things for themselves, allowing readers to test their own knowledge or verify something that isn&rsquo;t clear to them from the documentation alone. For example TypeScript&rsquo;s documentation allows users to hover over code samples to inspect the types as well as open it up in an online coding environment, while Golang and Rust&rsquo;s respective documentation sites have example programs which users are encouraged to edit and run online. Blog posts often have code snippets or GitHub gists for users to run, and in talks presenters may give live coding demos, which serve similar purposes.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 382.67px;"><img alt="The TypeScript playground, with an example opened from the Type Inferece documentation showing how JavaScript classes can work in TypeScript." src="images/image5.png" style="width: 601.70px; height: 382.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 382.67px;"><img alt="Golang&#39;s limited type inference is explained in &#39;A Tour of Go&#39;, with an example program the user is prompted to edit and run." src="images/image2.png" style="width: 601.70px; height: 382.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 488.00px;"><img alt="Rust&#39;s page on type inference is short, but has a well-commented and insightful example that can be run and edited inline in the browser." src="images/image15.png" style="width: 601.70px; height: 488.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Formal resources are usually aimed at a more mathematically-inclined audience, with less specific focus on any language or technology. It often uses mathematical terms and notation to convey ideas, which some readers may find difficult to understand. In particular, papers are often written in a very precise and succinct way with few examples, which can make them hard to interpret. This is likely due to the length constraints put in place by academic journals which incentives authors to cut more detailed explanations and examples from their work. Few papers and lecture notes would be immediately accessible to the general computer scientist, as papers often assume the reader has a strong grounding in the field already and lecture nodes are meant to be read in order, expecting the reader to have read the previous 20 lectures worth of notes. However, they do usually give clear and useful references for background and further reading which is useful for in-depth research on the topic, if not for an introduction. The implementation of a type inference algorithm and how it is applied to a specific language is rarely discussed. Where it is discussed the only languages used were Haskell, ML and OCaml. According to the StackOverflow Developers Survey</span><sup><a href="#ftnt36" id="ftnt_ref36">[36]</a></sup><span class="c0">&nbsp;Haskell is used by 1.8% of professional developers, while ML and OCaml are very rarely used in practice. These examples may therefore be of limited use to explain to developers how type inference is used in languages they are familiar with.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Finally, the different nature of resources means some are harder to correct or update with new information.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Informal resources generally seem to have the most errors, likely because it has little review process and may be written by anyone. Sometimes through comments other readers can provide corrections or clarifications, but these are not always incorporated into the material. However, commenting is not always available and also given the specific nature of some content few people are likely to view and suggest corrections to the content. Additionally, as informal resources are usually published as one-off talks or blog posts, it is rare for the document to be maintained and kept updated which can lead to inaccuracies if the underlying technology they are discussing has made breaking changes to its implementation.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Programming language documentation on type inference is generally accurate and well maintained. It is kept up to date with changes to the language, as usually there is a requirement to keep documentation updated in programming language projects. Additionally, almost all programming languages are open source and welcome external contributions to their documentation so readers are able to suggest improvements or raise issues about inaccuracies. Generally there is a review process, often requiring a maintainer of the programming language to approve the changes before edits are made.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Formal resources generally have few errors. For academic papers, this is likely a result of the peer-review process. Lecture notes are generally written by academics with relevant qualifications and educational backgrounds, who are likely to be knowledgeable on the subject. However, academic papers and lecture notes are unlikely to be updated, which means any inaccuracies in them are harder to correct. Exploring the literature we find there are some papers on type inference with errors which make understanding them fully more difficult. Finally, online encyclopedias can be reviewed and edited by many people, whose combined expertise generally results in accurate articles although they are prone to errors being introduced by even just a single contributor if they lack a review process. Luckily, except for errors, formal resources are unlikely to become outdated with time as much as informal resources. This is because formal resources focus on the more general underlying concepts over discussion on a specific implementation.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">This exploration into existing teaching resources is summarised in the table:</span></p><p class="c1 c4"><span class="c0"></span></p><a id="t.c414d112db19a40ea1a03ef46c2ea1ce80a4cd54"></a><a id="t.0"></a><table class="c33"><tbody><tr class="c16"><td class="c18" colspan="1" rowspan="1"><p class="c5 c4"><span class="c0"></span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c5"><span class="c9">Content</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c5"><span class="c9">Accessibility</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c5"><span class="c9">Correctness</span></p></td></tr><tr class="c16"><td class="c18" colspan="1" rowspan="1"><p class="c5"><span class="c9">Programming language documentation</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c5"><span class="c0">Explains how type inference is applied in the context of a specific programming language including error cases.</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c5"><span class="c0">Written in plain language with code samples and often interactive environments.</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c5"><span class="c0">Few errors, and generally well-maintained. Content may change as rules of the language do.</span></p></td></tr><tr class="c16"><td class="c18" colspan="1" rowspan="1"><p class="c5"><span class="c9">Formal resources</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c5"><span class="c0">Explains how type inference works at a general level.</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c5"><span class="c0">Often uses complex or mathematical notation and requires significant background reading, and is sometimes too brief at the expense of clarity.</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c5"><span class="c0">Few errors, although errors that do exist may persist given some resources can be hard to update. Generally relevant for a long time.</span></p></td></tr><tr class="c16"><td class="c18" colspan="1" rowspan="1"><p class="c5"><span class="c9">Informal resources</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c5"><span class="c0">Contains practical tips, however usually very specific and irrelevant to many programmers.</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c5"><span class="c0">Written in plain language with many code samples.</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c5"><span class="c0">Inaccuracies are common, and often go undetected or unresolved. Can become outdated quickly.</span></p></td></tr></tbody></table><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: (maybe?) discuss my exploration of existing teaching tools (wolframalpha, khanacademy, cymath, microsoft math, css diner)</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">This research into existing resources identifies strengths and weaknesses of different approaches. Given that this project is a one-off piece of work and the end product may not be maintained indefinitely, research into the content, correctness and longevity of resources suggests that the focus should be on the more general type inference concepts rather than specific programming language features. The tool should support error cases, not just correctly-typed expressions. It should be reviewed by my project supervisor tested with users to identify errors that can be resolved before project completion. To aid accessibility text should be written in plain language, the tool should offer several insightful examples and the output should avoid overuse of complex notation.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">As a tool that displays the output of type inference algorithms, to further determine the user interface for the output of the tool the presentation of type inference proofs is examined. My supervisor initially gave some examples of worked proofs for type inference, which also matched the format of proofs found in papers and in online resources. These proofs are broken down into steps, which each look at a particular subexpression and apply a certain typing rule. Depending on the type of proof (whether it is based purely on the typing rules or is more procedural and similar to an algorithm), this may also result in explicit unification resulting in a substitution to be applied.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Based on this, the tool is designed to show the result of type inference on an expression broken into steps. Given that the tool will be automated, the steps must be generated based on some deterministic procedure and so the steps will correspond to those of the type inference algorithms. This means the steps will need to show the unification operations performed and the resultant substitutions to fully explain how the types are being inferred.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">A basic UI mockup is shown below that takes an input expression and displays the inference algorithm steps beneath it. While simple, it is fundamentally similar to the final design of the application. It was also at this design that it was decided to show the type derivation feedback instantly on the same page, based on the limitations of previous related work and the strength of interactive playgrounds in programming language documentation. On top of this design, the final application adds a choice of algorithms, several samples to choose from and a display of the final type. In addition, the final application shows and explains the steps of the type inference algorithm when type errors are present.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 453.58px; height: 493.50px;"><img alt="Recreation of an initial sketch of the UI for the teaching tool." src="images/image13.png" style="width: 453.58px; height: 493.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">A step in the UI generally corresponds to a rule of the type inference algorithm. As the type inference algorithms are recursive, some rules may call the type inference algorithms again on a subexpression. In these cases it may be necessary to split rules of the type inference algorithm up into two parts, before and after a recursive call. This helps ensure the ordering of the steps makes logical sense.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">For example, this happens with function abstraction in algorithm W: the before step shows assigning a new type variable as the parameter&rsquo;s type, steps between show the results of the recursive call to the body, while the after step details the final type of the function abstraction expression.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 567.24px; height: 383.50px;"><img alt="Function abstraction in algorithm W requires two UI steps to represent one rule of the algorithm" src="images/image9.png" style="width: 567.24px; height: 383.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">In addition to the rule steps, algorithm M requires an extra beginning and end step. These are required as algorithm M requires an input type and does not return a type respectively. The first step is to create an initial new type $t0$ for the root node, and the final step is added to apply the final substitution to type $t0$ (effectively the value of $t0$ from the substitution).</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 576.15px; height: 376.10px;"><img alt="Algorithm M requires an initial and final step." src="images/image6.png" style="width: 576.15px; height: 376.10px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">To make it clear what part of the expression each step relates to, a representation of the expression as an AST with the relevant parts highlighted is shown at each step. The visualisation is computer generated and must fit in a fixed width space, and as such a vertical design was chosen to represent it. In this design, each box represents a tree node and the boxes are ordered in a vertical list. Nodes may have children, which they are attached to with edges to the left of the children.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 214.40px; height: 252.92px;"><img alt="The expression `let x = 3 in odd x` may be represented by this vertical AST." src="images/image21.png" style="width: 214.40px; height: 252.92px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">This vertical design was chosen over a horizontal design due to the space constraints of the tool page, and the difficulty in implementing a consistent and well functioning horizontal tree visualisation algorithm.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 487.50px; height: 174.11px;"><img alt="Example of what a more horizontal design of AST might look like." src="images/image8.png" style="width: 487.50px; height: 174.11px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Showing ASTs is preferable to just showing the relevant subexpression as it makes it clearer what part of the whole tree is being analysed. Showing ASTs is also preferable to showing the full expression and highlighting only the relevant part as it better demonstrates how the program is broken into its constituent parts, is clearer for showing syntactically-sugared features such as lists, and relates it to the original type inference algorithms more closely as users can see how similar AST structures follow similar type inference rules.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">To help relate the ASTs to the entered expression, when a user hovers over a part of the AST the matching part of the entered expression that corresponds to the hovered AST node is highlighted. For consistency and to help users understand larger subexpressions too this also works for non-leaf nodes of the tree.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 530.50px; height: 296.97px;"><img alt="Hovering ove r the &#39;function application&#39; node highlights the corresponding subexpression in the entered program." src="images/image17.png" style="width: 530.50px; height: 296.97px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: explain why web interface over desktop program</span></p><h2 class="c15" id="h.l33hnjbawceh"><span class="c22">Architecture</span></h2><p class="c1"><span class="c0">The design of the software aims to promote interchangeable, loosely-coupled modules to make it easy to adapt and extend. This also gives the project freedom to change over time in response to feedback, without having to redevelop common functionality.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: insert module diagram</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The alternative general module structure considered was to have the type inference modules standalone, to avoid depending on the language core. They would then be parameterized with methods to extract the necessary data from an arbitrary structured AST. This would allow the type inference algorithms to be used with any AST model. However, it would add significant complexity and performance overhead for not much gain as the language core is fairly lightweight. In addition, it would have meant utility functions, types and models could not be shared in the language core between type inference modules, meaning they would need to either have another separate module for shared utilities or have a large amount of code duplication.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: insert alternate module diagrams</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The main downside to splitting the project up into several modules is the tooling is a little more complex. Modules must be built separately and in the correct order which is slightly slower than compiling one larger app, and IDEs have to be set up to understand how to navigate between the modules. However, this is outweighed by the maintainability and extensibility benefits of keeping functionality in separate modules.</span></p><p class="c1 c4"><span class="c0"></span></p><h3 class="c13" id="h.dj2rwwqr30vu"><span class="c17">Choice of programming language</span></h3><p class="c1"><span class="c0">All of the modules are written in the same language, so they are all compatible and easy to get working together. Additionally, using one typed language allows for type-checking to ensure module APIs are correctly called and their results are used sensibly. To write a modern web application, a JavaScript-compatible language is the obvious choice as it is supported and promoted by all major browsers. TypeScript was chosen for this for several reasons.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>TypeScript is a statically-typed language similar to JavaScript which </span><span>transcompiles</span><span class="c0">&nbsp;to JavaScript that can be run in the browser. As a typed language, it provides the benefits of types listed earlier, which is especially important when dealing with a sizable codebase with several modules so was chosen over plain JavaScript.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Elm, CoffeeScript, PureScript and Dart are other languages that compile to JavaScript, however they lack rich package systems which can provide useful utilities and dependencies. Furthermore, Dart and Elm are largely focused on the presentation of data, so while it would be possible to write reusable independent libraries for type inference in them, it would not be easy.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Of the browser-compatible languages, TypeScript is the most used after JavaScript itself (according to the StackOverflow developers survey) and so developing and publishing packages in TypeScript may be useful for a wider audience.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Lastly, my own previous experiences with both TypeScript and the other languages informed the decision. Familiarity with TypeScript played a key role in choosing it over other languages targeting the browser.</span></p><h3 class="c13" id="h.hggmfighusoc"><span class="c17">Language core</span></h3><p class="c1"><span class="c0">The base module of the software, which all other parts depend on is the language core.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The language core contains key types and models, which are used throughout the rest of the software. These types and models are used in representing AST nodes, types, contexts, substitutions and other results from type inference algorithms. They also include function signatures which define the interfaces for modules containing type inference algorithms.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>In addition to these types and models, it contains a default global context with types for many common functions. This context is based on Haskell&rsquo;s Prelude, which makes it easy for learners familiar with Haskell or similar functional programming languages to use the tool.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The language core also contains key helper functions such as utilities to create types. For example, callers can construct and instance of a type as `tuple(char, boolean)` instead of `new TypeFuncApp(&lsquo;,&rsquo;, new TypeFuncApp(&lsquo;Char&rsquo;), new TypeFuncApp(&lsquo;Bool&rsquo;))`. It also contains helpers to combine and apply substitutions, as well as to perform unification. These helper functions can be tested independently, verifying the correctness before using them in dependent modules. Testing is discussed in more detail in the implementation chapter.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Lastly, the language core contains a lexer and parser. Together, these take an input program as a string and return an AST, or report that the program is syntactically invalid. The lexer splits the input string into tokens, while the parser operates on this stream of tokens to recognise higher-level program constructs and construct the AST nodes.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">A parser combinator library is used to perform the lexing and parsing. A parser combinator library was chosen over a recursive descent parser or an LL, LR or LALR parser generator as it was recommended by my project supervisor and several online sources discussing implementing functional language parsers. In addition the software needs to be compatible with running in the browser which most LL, LR and LALR generators do not support. In addition, none of these types of generators provides output that is easy to implement for the browser or debug manually, whereas parser combinators are relatively easier to implement by hand.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>The library chosen for lexing and parsing is Masala, one of the few parser combinator libraries implemented in JavaScript. Masala is based on Haskell&rsquo;s Parsec library, is tested for the browser and is well-maintained. In addition, it has strong TypeScript definitions which support its integration into the language module. Other libraries including </span><span>Parjs</span><span>, </span><span>Parsimmon</span><span>&nbsp;and </span><span>Chevrotrain</span><span>&nbsp;have weaker documentation, and </span><span>Parsimmon</span><span>&nbsp;lacks full TypeScript type definitions. Some other libraries like Jison and </span><span>Nearley</span><span class="c0">&nbsp;cannot easily and directly output the custom AST node classes, while Masala can. This helps extract the location of nodes in the source program to support being able to highlight where in the input expression an AST node has come from.</span></p><h3 class="c13" id="h.75leuokwbltp"><span class="c17">Type inference algorithms</span></h3><p class="c1"><span class="c0">On top of this language core are type inference algorithms W, W&rsquo; and M. Given an AST representing an expression, they return either a type or an error explaining why they were not able to infer the type. Along with these, they can also optionally return a sequence of steps taken as part of the algorithm. Each step includes a message and AST to be displayed, with appropriate parts of the AST highlighted.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Each type inference algorithm shares the same interface, allowing them to be used interchangeably. This means new algorithms conforming to this interface can be added to tools using the type inference algorithms, such as the web application, by simply changing the type inference library installed. Sharing the same interface also means that high-level module tests that call only the common function signature and assert on the final type can be shared across all the inference algorithms as they should all return the same type result, even if they take different steps to get there. This makes the development of tests easier so more can be written, and asserting the final types are the same across a number of varied cases improves confidence that the algorithms are implemented correctly.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Publishing the type inference algorithms separately helps keep the code clean and maintainable, and allows developers to only install the algorithms they need. While this does result in some code duplication, particularly between algorithm W and W&rsquo;, the benefits from keeping the modules small and easier to maintain individually make this trade-off worthwhile. Most of the common helper functions are already in the language core, which means the code duplication in the type inference modules is not excessive.</span></p><h3 class="c13" id="h.q67ivlz7h61r"><span class="c17">Web interface</span></h3><p class="c1"><span class="c0">Finally, depending on both the language core and the type inference algorithms is the web interface itself. This is the end-product that users interact with, implementing the user interface. Here users can type in a program, and view the steps the type inference algorithm took to infer its type. To do this, the web application passes the program to the language core which lexes and parses it into an AST, then passes that AST to a type inference library. The results of this are then shown to the user.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: diagram of pipeline: user enters program as string, lexer lexes as tokens, parser parses to AST, type inference algorithm returns steps, web application displays them</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The web application uses the React framework. Using a framework improves the structure of the code, as the application can be broken down into separate, independent components. These components can be reused to minimise code duplication, and can be individually unit tested with many testing libraries developed specifically for frameworks. As well as this, using a framework in combination with a module bundler such as webpack makes importing and depending on other modules (such as the language core and type inference algorithms) simple. And in combination with a transcompiler that converts modern JavaScript to be backwards compatible, such as Babel, the application can be made to work for users with older browsers.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">React was chosen over the alternative web frameworks Vue, Angular and Svelte. Vue and Angular are other popular frameworks, however for a one page application they are a little more complex than what is needed. In particular, Angular&rsquo;s component and dependency injection system, while useful in very large projects, would add significant unnecessary overhead to developing the system. Svelte is different to React, Vue and Angular in that it avoids managing a model of the page through a framework library that is part of the application, but instead compiles directly to simple JavaScript. This gives it better performance, but makes it harder to integrate with existing libraries and tooling. In addition, while Svelte supports TypeScript this support was only added recently (July 2020) and is much weaker than React&rsquo;s TypeScript support. Vue, Angular and Svelte are all significantly less popular than React (which is the most popular JavaScript framework). This means they have fewer available compatible packages and less community-developed documentation such as tutorials, guides or forums. In particular, Svelte is a new and much less widely-used framework, with less than 2,000 questions on StackOverflow compared to React&rsquo;s nearly 300,000.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Create React App sets up the initial structure of the web application. It includes a starter template, which is set up with the required dependencies to build a basic React site. A variant of the starter template is available with TypeScript support. Using this starter template rather than starting from scratch allows the project to focus on developing the novel type inference teaching tool parts of the web application, rather than being too concerned with the setup of the tooling. However, using Create React App does somewhat limit how the build can be configured without choosing to &ldquo;eject&rdquo; (an irreversible process that makes the implicit build tooling explicit, but results in more maintenance). For example, while it installs Webpack and Babel to bundle resources and transcompile to more-compatible JavaScript, their corresponding configurations cannot be edited without an &ldquo;eject&rdquo;.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The web application directly imports the type inference algorithms and the language core, and bundles them as part of the client application to be run entirely inside the user&rsquo;s web browser. Using a static site and doing the processing fully client-side was chosen over a client-server architecture to reduce latency, minimise running costs and maximise the resource&rsquo;s longevity. It also helps to simplify communication between the modules, which otherwise would either need to be manually specified or use a complex networking layer, likely using the proxy pattern along with dependency injection. In addition, potentially complex data types representing the AST would otherwise need to be reliably serialized and deserialized which is non-trivial when as classes they have non-serializable member functions.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Performing calculations client side reduces latency as users do not need to wait on the network to transport data back and forth. Parsing and inferring the type of simple expressions in the browser takes tens of milliseconds, compared to the hundreds of milliseconds that might be expected from a RESTful API. However, for particularly complex expressions where users have particularly weak hardware (such as older smartphones) relative to the hosting server, doing calculations client-side may be slightly slower than a client-server architecture. These cases will be rare, but happen when the networking-related overheads are outweighed by the difference in processing speeds between the server and client devices.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: insert bar graph comparing average laptop, average phone, average server-client, older smartphone, high latency server-client</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Avoiding dynamic calculations on the server means free static hosting sites such as GitHub pages can be used to serve the website. This significantly reduces running costs when compared to running a custom server to respond to requests.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The teaching tool&rsquo;s longevity is increased by serving a static artifact, as opposed to having dynamic server and client parts. A static website can easily be copied and archived, and as it can be run for free there is no incentive to shut the service down. TypeTool, a related work that also aimed to explain type inference, was client-server based. However, the server has since been taken down and so is no longer accessible. As the lexing, parsing and type inference process was done server-side, archive websites like the Internet Archive&rsquo;s Wayback Machine are unable to keep a copy of it, as they only store the static website content.</span></p><h2 class="c15" id="h.60njhv340fb0"><span class="c22">Analytics</span></h2><p class="c1"><span class="c0">To help evaluate the main teaching tool and understand user behaviour, a system to collect and store behavioural analytics data is required. This tool should respect user privacy settings, minimize personal data collected (ideally data collected should be anonymous) and be able to view a single event stream to understand how a user is using the application.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Several of the most popular existing analytics solutions were explored, including Google Analytics, Matomo, W3Counter, Simple Analytics, Angelfish, Open Web Analytics and AWStats.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The &ldquo;Do not track&rdquo; (DNT) browser setting is the simplest and most widely-supported way to indicate a user does not want to be tracked. However, Google Analytics, Angelfish, W3Counter, Open Web Analytics and AWStats do not respect &ldquo;do not track&rdquo; browser settings by default, and while possible are difficult to set up so that they do.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">IP addresses are classified as personal data under the General Data Protection Regulations (GDPR). Some analytics tools such as Angelfish, AWStats, Open Web Analytics and W3Counter collect and analyse IP addresses and other personal data. This presents a problem for using these analytics tools within the EU, as users must be informed as to how their personal data is collected and processed, and users have several rights relating to personal data such as the right to be forgotten, the right to object or the right to access. In addition, many of these tools use cookies and similar on-device storage technologies to track users, which require consent under the UK&rsquo;s Privacy and Electronic Communications Regulations (PECR). This would add significant unwanted overhead to the website for what is actually necessary.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>To understand user behaviour, a single event stream that shows the different steps they took would be most useful. For example, seeing in what order they try out type inference examples and whether they view the more in depth documentation is much more useful data for evaluating and improving the tool than aggregate data about user demographics. Many platforms such as AWStats focus on the latter, and do not offer event stream (also known as &lsquo;clickstream&rsquo; or &lsquo;</span><span>clickpath</span><span class="c0">&rsquo;) analytics. Some platforms meet in the middle, offering event tracking but cannot present these in individual user streams such as Google Analytics. Angelfish offers event stream analytics, but does not support custom events, such as choosing a type inference example.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Finally the most practical concern is their running cost. Google Analytics and W3Counter are the options with free plans, while other managed services such as Matomo Cloud and Simple Analytics are generally fairly expensive (both more than &pound;275 per year for their cheapest plan). The cheapest available Angelfish license costs over &pound;1,000 a year, and along with &ldquo;free&rdquo; options AWStats and Open Web Analytics needs to be hosted on a server which would incur server running and maintenance costs.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">These factors can be summarised in a comparison table:</span></p><p class="c1 c4"><span class="c0"></span></p><a id="t.29e3fb9b784918d1a45ed18c6fec669dc81b7026"></a><a id="t.1"></a><table class="c33"><tbody><tr class="c16"><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c9">Service</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c9">Obeys DNT</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c9">Anonymous</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c9">Event streams</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c9">Cost</span></p></td></tr><tr class="c16"><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">Google Analytics</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10007;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10007;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10007;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">Free</span></p></td></tr><tr class="c16"><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">Matomo Cloud</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10003;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10003;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10003;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&pound;348/year</span></p></td></tr><tr class="c16"><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">Matomo (self-hosted)</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10003;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10003;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10003;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">Server hosting</span></p></td></tr><tr class="c16"><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">W3Counter</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10007;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10007;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10003;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">Free</span></p></td></tr><tr class="c16"><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">Simple Analytics</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10003;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10003;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10003;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&pound;276/year</span></p></td></tr><tr class="c16"><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">Angelfish</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10007;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10007;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10003;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&pound;1123/year + server hosting</span></p></td></tr><tr class="c16"><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">Open Web Analytics</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10007;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10007;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10003;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">Server hosting</span></p></td></tr><tr class="c16"><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">AWStats</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10007;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10007;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">&#10007;</span></p></td><td class="c8" colspan="1" rowspan="1"><p class="c5"><span class="c0">Server hosting</span></p></td></tr></tbody></table><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">From this, we see that self-hosted Matomo is the only somewhat affordable option considering the budget for a 3rd year project. However, Matomo&rsquo;s set up is complicated and managing and maintaining a server is time-consuming. In particular, ensuring data is held securely would require running or renting a potentially-expensive private server indefinitely for hosting, as the available free departmental machines such as Joshua do not guarantee confidentiality, integrity or availability. The departmental machines also limit the installation of certain software which require root permissions, and many applications are not supported as Joshua libraries are outdated. In addition frequent restarts combined with limited powers to automatically run applications (through systemd units or similar) on Joshua means Matomo would have to be frequently restarted manually and may miss some user events.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">As such, we design a custom analytics platform to meet the three main criteria while having a very low running and maintenance cost.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">This platform offers an API to record custom events. The web application is then augmented to call the API to log certain user behaviours such as opening the help section or viewing a type inference example. An anonymised identifier is created for each new visit, which allows events to be collected and later viewed in anonymised custom event streams.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The data collected is the anonymised identifier, a timestamp, and any payload specified by the web application. For example to represent a user choosing to show the more detailed helper a JSON payload may be sent, such as:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```json</span></p><p class="c1"><span class="c0">{ &quot;name&quot;: &quot;help&quot;, &quot;value&quot;: &quot;show&quot; }</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Or, in the case where an button to set up the code example `map not []` the web application may send the payload: </span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```json</span></p><p class="c1"><span class="c0">{ &quot;name&quot;: &quot;codeButtonSet&quot;, &quot;value&quot;: &quot;map not []&quot; }</span></p><p class="c1"><span>```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The analytics API records this data, associating it with the anonymised identifier and timestamp. This is held securely for a configurable retention period, which is by default set to 90 days. While there are no legal requirements or responsibilities under PECR or GDPR to hold this data securely and minimize data retention as it is not personal data, doing so follows best ethical practices and reducing the volume of data held reduces running costs.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Running costs generally are kept low (&lt;&pound;1 per year) by using serverless cloud products. These are cloud products which offer compute and storage in individual on-demand units, rather than requiring renting of a permanent server. Serverless products also allow the analytics platform to easily scale to handle spikes in traffic, while being free when the site is not in use.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The custom event streams are then viewed in an analytics viewer. To keep the implementation consistent between the main project and the analytics sub-project, this too is written as a TypeScript application initialized with Create React App. Using a different framework would have resulted in less knowledge sharing between the two, and introduced additional unwanted complexity. Also, for similar reasons to the main project React was a well-suited framework for the viewer.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 362.67px;"><img alt="The analytics viewer, showing an example stream from the web application." src="images/image10.png" style="width: 601.70px; height: 362.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The viewer shows analytics events by stream, which can be navigated simply using the left sidebar which represents a list of streams. The main view shows a list of events within that stream, ordered by timestamp.</span></p><h1 class="c6" id="h.igepudpadp49"><span class="c19">Implementation</span></h1><p class="c1"><span class="c0">As detailed in the design section, the application is broken into several loosely-coupled modules, written in TypeScript. This chapter details their implementation, examining specific features of the code at a lower level.</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c15" id="h.o3ngfa303saw"><span class="c22">Language core</span></h2><p class="c1"><span class="c0">The language core contains models, utility and helper functions, and a lexer and parser. Together these comprise all the basics for interpreting and representing the expression language, and support implementing the type inference algorithm upon it.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">For clarity, in this section the term &lsquo;models&rsquo; will be used to mean TypeScript types, function signatures, interfaces and classes. The term &lsquo;types&rsquo; will be used exclusively to refer to the type objects, used for example as the result of type inference algorithms. For example the TypeScript expression in the implementation:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">new TypeVar(&lsquo;t0&rsquo;)</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>instantiates a TypeVar </span><span class="c11">model</span><span>&nbsp;that represents the </span><span class="c11">type</span><span>&nbsp;$t0$.</span></p><h3 class="c13" id="h.f0aymht9bwx3"><span class="c17">Models</span></h3><p class="c1"><span class="c0">TypeScript models are used to represent abstract syntax trees, types, contexts, substitutions, results and errors.</span></p><h4 class="c24" id="h.26q0jf334v10"><span class="c30">Abstract syntax trees</span></h4><p class="c1"><span class="c0">Abstract syntax trees are represented by their nodes alone. Each node corresponds to a subexpression, and contains the relevant information about itself and has references to its direct children. For example, the AST for the expression `\x -&gt; not x` may be represented by the node:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 517.98px; height: 391.50px;"><img alt="" src="images/image12.png" style="width: 517.98px; height: 391.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Here we see the tree is effectively just an `Abs` node, with a </span><span class="c11">parameter</span><span>&nbsp;by the name of &ldquo;x&rdquo; and </span><span class="c11">body</span><span>&nbsp;with a reference to another AST node. This body node is an `App` node, which has two properties: a </span><span class="c11">function</span><span>&nbsp;and </span><span class="c11">argument</span><span>, each being AST nodes of type `Var`. These `Var` nodes have a single property </span><span class="c11">name</span><span class="c0">, the name of the variable referenced.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">All nodes represent some expression in the original program. We declare a model `Expr` as the union of all the different node models, which we can use to represent a general subtree. This is used in defining the node models, for example in its simplest form the `Abs` node in TypeScript can be represented:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">interface Abs {</span></p><p class="c1"><span class="c0">&nbsp; param: string;</span></p><p class="c1"><span class="c0">&nbsp; body: Expr;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">To expand upon this model, we add the position in the original source program it was found at. This can be represented by a simple start and end index into the string of the source program, where the start is the index of the first character (0-indexed) and the end is the index of the last character plus one. For example, the `Var` node representing `not` in `\x -&gt; not x` starts at index 6 and ends at index 9. This indexing scheme is convenient as the length of the expression in the original source code can be calculated by simple subtraction, and the standard TypeScript string methods `slice` uses this convention. Therefore `code.slice(p.start, p.end)` will result in the source code specified by a position `p`. Positions are represented by the simple model:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">interface Position {</span></p><p class="c1"><span class="c0">&nbsp; start: number;</span></p><p class="c1"><span class="c0">&nbsp; end: number;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">In addition to positions, AST nodes have a notes property. This is represented as an optional string, and is used to record additional arbitrary information about certain nodes, for example that they should be highlighted in the UI or that they are from certain syntactically sugared expressions. For `Abs`, we now have:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">interface Abs {</span></p><p class="c1"><span class="c0">&nbsp; param: string;</span></p><p class="c1"><span class="c0">&nbsp; body: Expr;</span></p><p class="c1"><span class="c0">&nbsp; pos: Position;</span></p><p class="c1"><span class="c0">&nbsp; notes?: string;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Once constructed, properties should be immutable. Immutability prevents properties from being changed, which prevents certain hard-to-detect bugs as all object transformations must be explicit. For example, a method call to an object may not unexpectedly change that object. In addition, immutability helps . While immutability may have a small performance and memory usage overhead in some implementations, this may be offset (and in some cases, performance may be improved) by structural sharing. Structural sharing uses existing references to parts of an object when making a slightly changed copy of it. This reduces memory usage and reduces the overhead of creating new objects. This can be done safely given the knowledge objects are immutable as neither reference will attempt to update the child. For example:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: diagram</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Finally, immutability can improve performance when using front-end frameworks like React, which is used to implement the web application. With immutability, front-end frameworks can be sure objects have not changed on subsequent renders if they have referential equality (they point to the same object). Without immutability, objects may have changed between render calls so the front-end framework must re-render the page or perform deep value equality comparisons which require traversing the entire object. These are both potentially costly operations, so avoiding them through immutability brings performance benefits.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: discuss use of const and let</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Given the benefits of immutability, models are updated to generally be immutable, marked with the `readonly` modifier in TypeScript:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">interface Abs {</span></p><p class="c1"><span class="c0">&nbsp; readonly param: string;</span></p><p class="c1"><span class="c0">&nbsp; readonly body: Expr;</span></p><p class="c1"><span class="c0">&nbsp; readonly pos: Position;</span></p><p class="c1"><span class="c0">&nbsp; readonly notes?: string;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>To make constructing these models easier, we convert these TypeScript interfaces into classes. This allows us to use the </span><span class="c11">new</span><span>&nbsp;keyword to construct instances of these models, and we can use the </span><span class="c11">instanceof</span><span class="c0">&nbsp;operator to verify an AST node is of a specific type more easily. These are not possible with TypeScript interfaces alone.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">In addition, classes allow us to easily add default methods to objects. We add a `toString` method to all AST node classes which returns a string containing a program representing the node. This then gives us the final implementation for our `Abs` node:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">class Abs {</span></p><p class="c1"><span class="c0">&nbsp; readonly param: string;</span></p><p class="c1"><span class="c0">&nbsp; readonly body: Expr;</span></p><p class="c1"><span class="c0">&nbsp; readonly pos: Position;</span></p><p class="c1"><span class="c0">&nbsp; readonly notes?: string;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; constructor(param: string, body: Expr, pos: Position, notes?: string) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; this.param = param;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; this.body = body;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; this.pos = pos;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; this.notes = notes;</span></p><p class="c1"><span class="c0">&nbsp; }</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; toString(): string {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; return &#39;(\\&#39; + this.param + &#39; -&gt; &#39; + this.body.toString() + &#39;)&#39;</span></p><p class="c1"><span class="c0">&nbsp; }</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">This structure is used for all the AST node models, including:</span></p><ul class="c14 lst-kix_u6w4ccd2asj5-0 start"><li class="c1 c7 li-bullet-0"><span class="c0">`Var` for variables</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`App` for function application</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`Abs`, for function abstraction, as shown above</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`Let` for let statements</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`CharLiteral` and `NumberLiteral` for literal constants</span></li></ul><p class="c1 c4"><span class="c0"></span></p><h4 class="c24" id="h.bzdo56ibho4h"><span class="c30">Types</span></h4><p class="c1"><span class="c0">As discussed in the background chapter, monotypes are constructed from type variables and type function applications. We consider basic types (such as $Bool$ or $Int$) to be type function applications on zero arguments. Polytypes are monotypes with zero or more for-all quantifier variables.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">For simplicity when modelling polytypes, we consider type variables bound at the highest level. Any type that can be expressed with for-all quantifiers at lower levels, is equivalent to moving those bindings to the top level. For example, $\forall a. (a \rightarrow (\forall b. (b \rightarrow (a, b)))$ is equivalent to $\forall a \forall b. (a \rightarrow b \rightarrow (a, b))$.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">From this, and following the same reasoning about using classes with readonly properties we can develop simple models for types. Here we remove constructors and toString methods for simplicity.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">type MonoType = TypeVar | TypeFuncApp;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">class TypeVar {</span></p><p class="c1"><span class="c0">&nbsp; readonly name: string;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; /* constructor and toString methods */</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">type TypeFunc = &quot;-&gt;&quot; | &quot;[]&quot; | &quot;Maybe&quot; | &quot;Either&quot; | &quot;Int&quot; | &quot;Char&quot; | &quot;Bool&quot; | &quot;,&quot; | &quot;,,&quot; | /* ... */;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">class TypeFuncApp {</span></p><p class="c1"><span class="c0">&nbsp; readonly constructorName: TypeFunc;</span></p><p class="c1"><span class="c0">&nbsp; readonly args: MonoType[];</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; /* constructor and toString methods */</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">class PolyType {</span></p><p class="c1"><span class="c0">&nbsp; readonly quantifiedVars: string[];</span></p><p class="c1"><span class="c0">&nbsp; readonly monoType: MonoType;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; /* constructor and toString methods */</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">While PolyType&rsquo;s `quantifiedVars` property could be modelled with `TypeVar[]`, for simplicity `string[]` was chosen as the methods on these type variables are never called.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The constructors are all trivial, and simply set the corresponding properties in the object. The `toString` methods are fairly simple for `TypeVar` and `PolyType`, however `TypeFuncApp` has additional logic to pretty-format some types. For example, it formats types like $[(Bool, Int)] \rightarrow Int$ rather than $\rightarrow ([] (, (Bool) (Int))) (Int)$ which would be the result if it treated all type functions equivalently in prefix notation with explicit bracketing. To do this it uses case matching, with different rules depending on the type function used.</span></p><h4 class="c24" id="h.ux3btyb2wvh8"><span class="c30">Contexts and substitutions</span></h4><p class="c1"><span class="c0">A context, as defined in the background chapter, is a mapping from variable names to their corresponding types. This informs the type inference algorithm what variables are in scope, and what their types are.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">This is modelled in TypeScript as a simple object which has string keys (variable names) and type values. Specifically these type values are polytypes, because as stated before monotypes can be considered polytypes with zero for-all quantified variables. This is written:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">interface Context { [name: string]: PolyType | undefined }</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Substitutions can be seen as mappings from type variable names to corresponding types they should be substituted with. In Hindley-Milner there is no need to ever substitute type variables with polytypes, so we can assume these are only monotypes. This therefore can be represented with a model similar to contexts:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">interface Substitution { [name: string]: MonoType | undefined }</span></p><p class="c1"><span class="c0">```</span></p><h4 class="c24" id="h.5yk2zijb0axq"><span class="c30">Results and errors</span></h4><p class="c1"><span class="c0">The parser and type inference algorithms use response models to return their results. A `Response` from one of these methods may either be a `Rejected` or `Accepted`, indicating the input was invalid or valid respectively.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">For example, if a syntax error is present in the program passed to the parser, it may return a `Rejected` model with the location of the error and a message explaining the issue. Alternatively if a valid program is passed to the parser, it returns an `Accepted` model with the AST representation as its value. Similarly, the type inference algorithms return `Rejected` if type inference fails, and `Accepted` if it succeeds.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">These models are defined:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">type Response&lt;A, R = undefined&gt; = Accepted&lt;A&gt; | Rejected&lt;R&gt;;</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">interface Rejected&lt;T&gt; {</span></p><p class="c1"><span class="c0">&nbsp; value?: T;</span></p><p class="c1"><span class="c0">&nbsp; accepted: false;</span></p><p class="c1"><span class="c0">&nbsp; issuePosition: Position;</span></p><p class="c1"><span class="c0">&nbsp; message: string;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">interface Accepted&lt;T&gt; {</span></p><p class="c1"><span class="c0">&nbsp; value: T;</span></p><p class="c1"><span class="c0">&nbsp; accepted: true;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">These models have generic parameters which can be used to specify the type of value expected to be returned. For example, an `Response&lt;Expr, ParseError&gt;` represents a model which may either be an `Accepted&lt;Expr&gt;`, containing an `Expr` as a value, or a `Rejected&lt;ParseError&gt;`, containing an optional `ParseError` as a value.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">In addition to this, a `TypeResult` container is defined which is used as part of the function signature for type inference algorithms. This contains a type, representing the overall type of the expression, and the steps the type inference algorithm took to derive that type. Each step has a message and AST to go with it, to match the designed user interface steps.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">interface TypeResult {</span></p><p class="c1"><span class="c0">&nbsp; type: MonoType;</span></p><p class="c1"><span class="c0">&nbsp; steps: { message: string, ast: Expr }[];</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Type inference algorithms return a `Response` where if `Accepted`, the value should be a `TypeResult` object. If `Rejected`, the value should be the steps only in the `TypeResult`. A TypeScript utility, `Omit` is used to remove the `&rsquo;type&rsquo;` property from the TypeResult in the rejection case. This gives the overall return type for type inference algorithms:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">Response&lt;TypeResult, Omit&lt;TypeResult, &#39;type&#39;&gt;&gt;</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: consider cutting/moving the following paragraph</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">In addition to these result wrappers, the parser and type inference algorithms also offer an alternative simple interface where just the AST or type is returned without any wrappers. In this case, if an error is found with the input a `ParseError` or `TypeInferenceError` is raised, which should be caught by the caller. These errors are also used internally by the methods returning result wrappers.</span></p><h3 class="c13" id="h.sw77qek8b49p"><span class="c17">Helper functions</span></h3><p class="c1"><span class="c0">Several helper functions are implemented in the language core that are relevant to the parser and type inference algorithms. Generally these perform the functions by the same name defined in the background chapter:</span></p><ul class="c14 lst-kix_f9hviix50sbl-0 start"><li class="c1 c7 li-bullet-0"><span class="c0">`apply` applies a substitution to a type or context</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`combine` combines substitutions</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`unify` attempts to find a unifying substitution given two monotypes</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`contains` returns whether a type contains a certain type variable</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`freeVars` returns an array of free variables names in a given type or context</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`inst` instantiates a type, replacing all for-all quantified type variables with new type variables</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`generalise` fully generalises a type, for-all quantifying any free type variables in the type that are not free in the given context</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`unique` removes duplicate elements from an array</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`diff` performs the list difference operation</span></li></ul><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Generally the helper functions are written recursively, often with the base case being the when the function is called with a `TypeVar` or a `TypeFuncApp` with no arguments. This helps keep function implementations simple and maintainable.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">As key helper functions it is important that their correctness can be depended upon. To verify correctness, many automated unit tests are run against them using the Jest framework. Jest is a simple to set-up test runner and is recommended by the authors of React for testing React projects. To reduce tooling complexity Jest is used for all automated testing throughout the project.</span></p><h3 class="c13" id="h.qbtwwllp8tw6"><span class="c17">Lexer and Parser</span></h3><p class="c1"><span class="c0">The lexer and parser use the Masala library, as explained in the design chapter.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The GenLex class from the library is used to generate a lexer, which is in turn used for lexing. An instance of GenLex is used to define different tokens, such as identifiers, parentheses, numeric literals and keywords such as &lsquo;let&rsquo;. For example, the left parenthesis token is defined:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">const lparen = genlex.tokenize(C.char(&#39;(&#39;), &#39;lparen&#39;);</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Once the input program is split into tokens, the parser can attempt to construct an AST. Masala is a parser combinator library, which means functions are chained to parse the expression, each consuming a part of the input.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The parser starts by trying to parse the given program as one of many types of node, using Masala&rsquo;s `F.try` utility. This tries to parse the expression with several different construct-specific parsers, taking the first valid match.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">These construct-specific parsers match the basic constant literal, variable, function abstraction and let statement expressions defined in Hindley Milner. In addition, we add parsers for tuples and lists that support sugared syntax to allow users to construct these easily. This syntactic sugar is similar to Haskell&rsquo;s for lists and tuples. For example `[1, 2, 3]` instead of &nbsp;`cons 1 (cons 2 (cons 3 [])` and `(1, True)` instead of `(,) 1 True`. Lastly, we add a parser for parenthesized expressions, to make the order of operations explicit.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Once we match one of these parsers, we use it to construct an AST node. Each construct-specific parser returns a single `Expr`, and so implements the TypeScript interface `SingleParser&lt;Expr&gt;`. Generally each construct-specific parser extracts the value from the matched tokens, and extracts the location of the node in the source program from a parser metadata object from Masala. The original Masala library does not provide the absolute offset in the source program consistently for all tokens through this metadata object. As Masala is an open-source library, it can be forked and modified. The library was modified to provide the metadata object consistently, and this forked version is used in the implementation to get the position property for AST nodes. For example, the rule for parsing and extracting details about a `Var` node is:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">const VAR = () =&gt; identifier.map((value, r) =&gt; new Var(value, getPos(r)));</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">(`getPos` is a helper function which extracts the token position from the Masala metadata object `r`)</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">More complicated rules such as for `Abs` use Masala&rsquo;s tuple model, which collects multiple values and allows accessing them by index:</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">```typescript</span></p><p class="c1"><span class="c0">const ABS = () =&gt;</span></p><p class="c1"><span class="c0">&nbsp; backslash.map((v, r) =&gt; r.location() - 1) // \, and store the start location</span></p><p class="c1"><span class="c0">&nbsp; .then(identifier) // parameter</span></p><p class="c1"><span class="c0">&nbsp; .then(arrow.drop()) // -&gt;, dropped as we don&rsquo;t need information from it</span></p><p class="c1"><span class="c0">&nbsp; .then(F.lazy(expression)) // body, F.lazy avoids infinite loop as expression references ABS</span></p><p class="c1"><span class="c0">&nbsp; // map to an Abs. tuple is (startLocation: string, parameter: string, body: Expr)</span></p><p class="c1"><span class="c0">&nbsp; .map((tuple, r) =&gt; new Abs(tuple.at(1), tuple.at(2), { start: tuple.at(0), end: r.location() }))</span></p><p class="c1"><span class="c0">```</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">At the end of the construct-specific parsers, in the main parser we then call `.rep().array().map(nestLeft)`. Together, these handle function application:</span></p><ul class="c14 lst-kix_d6ra4nqnljxz-0 start"><li class="c1 c7 li-bullet-0"><span class="c0">`.rep()` tells the parser to require one or more construct-specific parsers (similar to the $+$ symbol in RegEx). This matches function application, as this matches subexpressions separated by whitespaces.</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`.array()` tells the parser to map these one or more construct-specific parser results into an array (which will result in an array of `Expr`s).</span></li><li class="c1 c7 li-bullet-0"><span class="c0">`.map(nestLeft)` maps the resultant array through the helper function `nestLeft`. This `nestLeft` function reduces a given array of expressions into an `App` model, nesting towards the left as is convention for function application. For example, the array of expressions `[a, b, c, d]` would be transformed to an `App` node representing applying the functions in order `((a b) c) d`. In the case only one expression is passed to `nestLeft` (i.e., there is not a function application) it simply returns the provided expression.</span></li></ul><h3 class="c13" id="h.flyu66glh76t"><span class="c17">Type inference algorithms</span></h3><p class="c1"><span class="c0">TODO: discuss implementation of type inference algorithms. How expressions are matched and how rules are executed. Give an example of a rule. Implemented algorithm W in a mix of class-based and functions, then reimplemented to be just functions. Adding algorithm M and W&rsquo;. How is the logger implemented: how is it constructed, how does it log steps, how is it passed recursively, how are results returned at the end. How ASTs are cloned and highlighted. testing (+custom test matcher)</span></p><h3 class="c13" id="h.jqmg1n3w35mp"><span class="c17">Web application</span></h3><p class="c1"><span class="c0">TODO: web application, explain the different components, how state is managed, why React function components and hooks over class components, use of useMemo (+with performance analysis), how the AST is displayed, how different algorithms are called, how the help modal works (generated from default context), testing</span></p><h3 class="c13" id="h.39bhrrv1fi5p"><span class="c17">Analytics</span></h3><p class="c1"><span class="c0">TODO: analytics, AWS implementation (lambdas, s3, api gateway, bucket policies), viewer (s3 sync, server, react front-end)</span></p><h1 class="c6" id="h.e6letww4nhn0"><span class="c19">Evaluation</span></h1><p class="c1"><span class="c0">Maybe also analyse performance?</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span>Compare</span><span class="c0">&nbsp;to existing available libraries?</span></p><p class="c1 c4"><span class="c0"></span></p><h2 class="c15" id="h.bsy9mpun8nk3"><span class="c22">User testing</span></h2><p class="c1"><span class="c0">Lay out the aims of user testing, i.e.: (goals increasing in &lsquo;scope&rsquo;)</span></p><p class="c1"><span class="c0">- software is accessible and usable</span></p><p class="c1"><span class="c0">- the results can be understood</span></p><p class="c1"><span class="c0">- it improves students&rsquo; understanding of types and type inference</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">How the survey was constructed and how that relates to aims</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">How the survey was distributed and incentivised</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">How analytics data was collected and how that relates to aims</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">How participants privacy was protected</span></p><h3 class="c13" id="h.yqiowsgjmohq"><span class="c17">Survey</span></h3><p class="c1"><span class="c0">Questions:</span></p><p class="c1"><span class="c0">- Try entering: map odd []. Try to understand the steps. What is the unifying substitution performed in step 3?</span></p><p class="c1"><span class="c0">- Try entering: not 3. Try to understand the steps. What is the problem found?</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">TODO: Expand on what options were available for these questions and why</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">These questions were to verify users were able to access, use and interpret the results of the tool. This helps test the hypothesis that the software was accessible and usable, and that results could be understood.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The first had 91% of respondents select the correct answer. 2 respondents chose the type distractor, and 1 respondent entered a different substitution. 1 respondent did not understand the output enough.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">The second had 100% of respondents select the correct answer.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">In both questions, no respondents selected that they could not access or use the software, and the high correct response rate for both questions support hypotheses 1 and 2.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Questions:</span></p><p class="c1"><span class="c0">- What is really helpful about this tool?</span></p><p class="c1"><span class="c0">- What could be improved in this tool?</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">These questions were to better understand qualitatively what helped students understand type inference, so the tool could be improved. Determining what is most helpful about the tool allows focusing on those parts, while asking what could be improved highlights areas to be changed.</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Positive themes found were:</span></p><p class="c1"><span class="c0">- 2x Function application was explained well, which also helped explain curried functions</span></p><p class="c1"><span class="c0">- 23x Steps are clear / easy-to-understand</span></p><p class="c1"><span class="c0">- 15x Steps are well-presented / well-visualised</span></p><p class="c1"><span class="c0">- 8x Tool explains why invalid expressions are invalid</span></p><p class="c1"><span class="c0">- 8x Showing substitutions helped explain unification</span></p><p class="c1"><span class="c0">- Learnt how let syntax worked</span></p><p class="c1"><span class="c0">- 9x Liked visual design / colour scheme</span></p><p class="c1"><span class="c0">- Tool helpful for more complex examples</span></p><p class="c1"><span class="c0">- Liked being able to try different things, felt it was more effective than slides/books</span></p><p class="c1"><span class="c0">- Examples were helpful</span></p><p class="c1"><span class="c0">- 13x helped me understand unification</span></p><p class="c1"><span class="c0">- 11x helped me understand type inference</span></p><p class="c1"><span class="c0">- 4x helped me understand Haskell</span></p><p class="c1"><span class="c0">- Application is very fast</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Improvement themes found were:</span></p><p class="c1"><span class="c0">- 2x Information on homepage could be made more obvious</span></p><p class="c1"><span class="c0">- Contact details on the website could help report bugs, give feedback</span></p><p class="c1"><span class="c0">- Automatically suggesting typo corrections e.g. &lsquo;Fals&rsquo; to &lsquo;False&rsquo;</span></p><p class="c1"><span class="c0">- On mobile changing the input expression should not cause the screen to move</span></p><p class="c1"><span class="c0">- Adding functor and applicative support</span></p><p class="c1"><span class="c0">- Adding support for list comprehensions</span></p><p class="c1"><span class="c0">- 5x Adding more general information on the HM type system and the HM algorithm</span></p><p class="c1"><span class="c0">- 4x Using arrows to navigate through steps rather than scrolling</span></p><p class="c1"><span class="c0">- 3x Function application step could be made clearer</span></p><p class="c1"><span>- 2x Fix typo &lsquo;</span><span>instatiate</span><span class="c0">&rsquo; to &lsquo;instantiate&rsquo;</span></p><p class="c1"><span class="c0">- Support infix expressions</span></p><p class="c1"><span class="c0">- Adding a quiz mode</span></p><p class="c1"><span class="c0">- 3x Improve wording of function application step</span></p><p class="c1"><span class="c0">- 2x Adding support for declaring custom types</span></p><p class="c1"><span class="c0">- Swapping order of AST and explaining content</span></p><p class="c1"><span class="c0">- 2x Making it clearer the expression box was a text input</span></p><p class="c1"><span class="c0">- Want input expression to be visible when scrolled down the page</span></p><p class="c1"><span class="c0">- 1x Disliked colour scheme</span></p><p class="c1"><span class="c0">- Use more mathematical notation</span></p><p class="c1"><span class="c0">- 2x Add animation</span></p><p class="c1"><span class="c0">- Add dark theme</span></p><h3 class="c13" id="h.67g05flyfv0z"><span class="c17">Analytics</span></h3><h3 class="c13" id="h.q5st3bb4afm1"><span class="c17">Ethics</span></h3><h1 class="c6" id="h.3j8xp631ygy"><span class="c19">Project Management</span></h1><p class="c1"><span class="c0">TODO: consider whether this section is necessary?</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Version control with Git, Git hosting on GitHub, backups (can probably take some stuff from spec/progress report?)</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Developed gdoc2latex</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Set up CI system to build latex docs</span></p><p class="c1 c4"><span class="c0"></span></p><p class="c1"><span class="c0">Tried using Docker to run latex compilation step in GitHub actions, but found it was significantly slower (2 mins vs 45 seconds) than installing texlive-latex-extra and texlive-bibtex-extra on the runner directly.</span></p><h1 class="c6" id="h.fc67ipatea73"><span class="c19">Conclusions</span></h1><p class="c1"><span class="c0">TODO: further work: lazy loading of libraries, adding custom type environments</span></p><h2 class="c15" id="h.60yvcrl0lpu"><span class="c22">Further Work</span></h2><h2 class="c15" id="h.xqaef57orpsv"><span class="c22">Acknowledgements</span></h2><p class="c1"><span>This document was typeset using a derivative of the CS310 starter pack</span><sup><a href="#ftnt37" id="ftnt_ref37">[37]</a></sup><span class="c0">&nbsp;by Michael Gale, licensed under CC BY 4.0.</span></p><hr class="c35"><div><p class="c3"><a href="#ftnt_ref1" id="ftnt1">[1]</a><span class="c2">&nbsp;@inproceedings{li2003tool,</span></p><p class="c3"><span class="c2">&nbsp; title={Tool support for refactoring functional programs},</span></p><p class="c3"><span class="c2">&nbsp; author={Li, Huiqing and Reinke, Claus and Thompson, Simon},</span></p><p class="c3"><span class="c21">&nbsp; </span><span class="c21">booktitle</span><span class="c2">={Proceedings of the 2003 ACM SIGPLAN workshop on Haskell},</span></p><p class="c3"><span class="c2">&nbsp; pages={27--38},</span></p><p class="c3"><span class="c2">&nbsp; year={2003}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref2" id="ftnt2">[2]</a><span class="c2">&nbsp;@thesis{hobmaierimproving,</span></p><p class="c3"><span class="c2">&nbsp; title={Improving the Quality of {OpenAPI} Specifications Using {TypeScript} Types and Annotations},</span></p><p class="c3"><span class="c2">&nbsp; author={Hobmaier, Wolfgang},<br> &nbsp;type={Bachelor&#39;s Thesis},</span></p><p class="c3"><span class="c2">&nbsp; year={2020}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref3" id="ftnt3">[3]</a><span class="c2">&nbsp;@inproceedings{asaduzzaman2015exploring,</span></p><p class="c3"><span class="c2">&nbsp; title={Exploring {API} method parameter recommendations},</span></p><p class="c3"><span class="c2">&nbsp; author={Asaduzzaman, Muhammad and Roy, Chanchal K and Monir, Samiul and Schneider, Kevin A},</span></p><p class="c3"><span class="c2">&nbsp; booktitle={2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)},</span></p><p class="c3"><span class="c2">&nbsp; pages={271--280},</span></p><p class="c3"><span class="c2">&nbsp; year={2015},</span></p><p class="c3"><span class="c2">&nbsp; organization={IEEE}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref4" id="ftnt4">[4]</a><span class="c2">&nbsp;@inproceedings{simoes2004typetool,</span></p><p class="c3"><span class="c2">&nbsp; title={{TypeTool}: A type inference visualization tool},</span></p><p class="c3"><span class="c21">&nbsp; author={Simoes, Hugo and Florido, M</span><span class="c21 c32">&aacute;</span><span class="c2">rio},</span></p><p class="c3"><span class="c21">&nbsp; </span><span class="c21">booktitle</span><span class="c2">={WFLP&rsquo;04: Proc. 13th Intl. Workshop on Functional and (Constraint) Logic Programming, H. Kuchen, Ed. RWTH Aachen, Dept. Comp. Sc., Technical report AIB-2004-05},</span></p><p class="c3"><span class="c2">&nbsp; pages={48--61},</span></p><p class="c3"><span class="c2">&nbsp; year={2004},</span></p><p class="c3"><span class="c2">&nbsp; organization={Citeseer}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref5" id="ftnt5">[5]</a><span class="c2">&nbsp;@article{mory2004feedback,</span></p><p class="c3"><span class="c2">&nbsp; title={Feedback research revisited},</span></p><p class="c3"><span class="c2">&nbsp; author={Mory, Edna Holland},</span></p><p class="c3"><span class="c2">&nbsp; year={2004},</span></p><p class="c3"><span class="c2">&nbsp; publisher={Lawrence Erlbaum Associates Publishers}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref6" id="ftnt6">[6]</a><span class="c2">&nbsp;@article{lee1989effects,</span></p><p class="c3"><span class="c2">&nbsp; title={The effects of feedback and second try in computer-assisted instruction for rule-learning task},</span></p><p class="c3"><span class="c2">&nbsp; author={Lee, Doris},</span></p><p class="c3"><span class="c2">&nbsp; year={1989}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref7" id="ftnt7">[7]</a><span class="c2">&nbsp;@article{jung2000visualisation,</span></p><p class="c3"><span class="c2">&nbsp; title={A visualisation of polymorphic type checking},</span></p><p class="c3"><span class="c2">&nbsp; author={Jung, Yang and Michaelson, Greg},</span></p><p class="c3"><span class="c2">&nbsp; journal={Journal of Functional Programming},</span></p><p class="c3"><span class="c2">&nbsp; volume={10},</span></p><p class="c3"><span class="c2">&nbsp; number={1},</span></p><p class="c3"><span class="c2">&nbsp; pages={57--75},</span></p><p class="c3"><span class="c2">&nbsp; year={2000}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref8" id="ftnt8">[8]</a><span class="c2">&nbsp;@article{clerici2009nimotoons,</span></p><p class="c3"><span class="c2">&nbsp; title={{Nimotoons}: a totally graphic workbench for program tuning and experimentation},</span></p><p class="c3"><span class="c2">&nbsp; author={Clerici, Silvia and Zoltan, Cristina and Prestigiacomo, Guillermo},</span></p><p class="c3"><span class="c2">&nbsp; journal={Electronic Notes in Theoretical Computer Science},</span></p><p class="c3"><span class="c2">&nbsp; volume={258},</span></p><p class="c3"><span class="c2">&nbsp; number={1},</span></p><p class="c3"><span class="c2">&nbsp; pages={93--107},</span></p><p class="c3"><span class="c2">&nbsp; year={2009},</span></p><p class="c3"><span class="c2">&nbsp; publisher={Elsevier}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref9" id="ftnt9">[9]</a><span class="c2">&nbsp;@article{ruiz2009tilc,</span></p><p class="c3"><span class="c2">&nbsp; title={{TILC}: The interactive lambda-calculus tracer},</span></p><p class="c3"><span class="c2">&nbsp; author={Ruiz, David and Villaret, Mateu},</span></p><p class="c3"><span class="c2">&nbsp; journal={Electronic Notes in Theoretical Computer Science},</span></p><p class="c3"><span class="c2">&nbsp; volume={248},</span></p><p class="c3"><span class="c2">&nbsp; pages={173--183},</span></p><p class="c3"><span class="c2">&nbsp; year={2009},</span></p><p class="c3"><span class="c2">&nbsp; publisher={Elsevier}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref10" id="ftnt10">[10]</a><span class="c2">&nbsp;@article{church1936unsolvable,</span></p><p class="c3"><span class="c2">&nbsp; title={An unsolvable problem of elementary number theory},</span></p><p class="c3"><span class="c2">&nbsp; author={Church, Alonzo},</span></p><p class="c3"><span class="c2">&nbsp; journal={American journal of mathematics},</span></p><p class="c3"><span class="c2">&nbsp; volume={58},</span></p><p class="c3"><span class="c2">&nbsp; number={2},</span></p><p class="c3"><span class="c2">&nbsp; pages={345--363},</span></p><p class="c3"><span class="c2">&nbsp; year={1936},</span></p><p class="c3"><span class="c2">&nbsp; publisher={JSTOR}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref11" id="ftnt11">[11]</a><span class="c2">&nbsp;@article{church1940formulation,</span></p><p class="c3"><span class="c2">&nbsp; title={A formulation of the simple theory of types},</span></p><p class="c3"><span class="c2">&nbsp; author={Church, Alonzo},</span></p><p class="c3"><span class="c2">&nbsp; journal={The journal of symbolic logic},</span></p><p class="c3"><span class="c2">&nbsp; volume={5},</span></p><p class="c3"><span class="c2">&nbsp; number={2},</span></p><p class="c3"><span class="c2">&nbsp; pages={56--68},</span></p><p class="c3"><span class="c2">&nbsp; year={1940},</span></p><p class="c3"><span class="c2">&nbsp; publisher={JSTOR}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref12" id="ftnt12">[12]</a><span class="c2">&nbsp;@article{hindley1969principal,</span></p><p class="c3"><span class="c2">&nbsp; title={The principal type-scheme of an object in combinatory logic},</span></p><p class="c3"><span class="c2">&nbsp; author={Hindley, Roger},</span></p><p class="c3"><span class="c2">&nbsp; journal={Transactions of the american mathematical society},</span></p><p class="c3"><span class="c2">&nbsp; volume={146},</span></p><p class="c3"><span class="c2">&nbsp; pages={29--60},</span></p><p class="c3"><span class="c2">&nbsp; year={1969},</span></p><p class="c3"><span class="c2">&nbsp; publisher={JSTOR}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref13" id="ftnt13">[13]</a><span class="c2">&nbsp;@article{milner1978theory,</span></p><p class="c3"><span class="c2">&nbsp; title={A theory of type polymorphism in programming},</span></p><p class="c3"><span class="c2">&nbsp; author={Milner, Robin},</span></p><p class="c3"><span class="c2">&nbsp; journal={Journal of computer and system sciences},</span></p><p class="c3"><span class="c2">&nbsp; volume={17},</span></p><p class="c3"><span class="c2">&nbsp; number={3},</span></p><p class="c3"><span class="c2">&nbsp; pages={348--375},</span></p><p class="c3"><span class="c2">&nbsp; year={1978},</span></p><p class="c3"><span class="c2">&nbsp; publisher={Elsevier}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref14" id="ftnt14">[14]</a><span class="c2">&nbsp;@article{wells1999typability,</span></p><p class="c3"><span class="c2">&nbsp; title={Typability and type checking in {System F} are equivalent and undecidable},</span></p><p class="c3"><span class="c2">&nbsp; author={Wells, Joe B},</span></p><p class="c3"><span class="c2">&nbsp; journal={Annals of Pure and Applied Logic},</span></p><p class="c3"><span class="c2">&nbsp; volume={98},</span></p><p class="c3"><span class="c2">&nbsp; number={1-3},</span></p><p class="c3"><span class="c2">&nbsp; pages={111--156},</span></p><p class="c3"><span class="c2">&nbsp; year={1999},</span></p><p class="c3"><span class="c2">&nbsp; publisher={Elsevier}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref15" id="ftnt15">[15]</a><span class="c2">&nbsp;@book{harper1986standard,</span></p><p class="c3"><span class="c2">&nbsp; title={{Standard ML}},</span></p><p class="c3"><span class="c2">&nbsp; author={Harper, Robert and MacQueen, David and Milner, Robin},</span></p><p class="c3"><span class="c2">&nbsp; year={1986},</span></p><p class="c3"><span class="c2">&nbsp; publisher={Department of Computer Science, University of Edinburgh}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref16" id="ftnt16">[16]</a><span class="c2">&nbsp;@article{hall1996type,</span></p><p class="c3"><span class="c2">&nbsp; title={Type classes in {Haskell}},</span></p><p class="c3"><span class="c2">&nbsp; author={Hall, Cordelia V and Hammond, Kevin and Peyton Jones, Simon L and Wadler, Philip L},</span></p><p class="c3"><span class="c2">&nbsp; journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},</span></p><p class="c3"><span class="c2">&nbsp; volume={18},</span></p><p class="c3"><span class="c2">&nbsp; number={2},</span></p><p class="c3"><span class="c2">&nbsp; pages={109--138},</span></p><p class="c3"><span class="c2">&nbsp; year={1996},</span></p><p class="c3"><span class="c2">&nbsp; publisher={ACM New York, NY, USA}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref17" id="ftnt17">[17]</a><span class="c2">&nbsp;@book{jones2003qualified,</span></p><p class="c3"><span class="c2">&nbsp; title={Qualified types: theory and practice},</span></p><p class="c3"><span class="c2">&nbsp; author={Jones, Mark P},</span></p><p class="c3"><span class="c2">&nbsp; number={9},</span></p><p class="c3"><span class="c2">&nbsp; year={2003},</span></p><p class="c3"><span class="c2">&nbsp; publisher={Cambridge University Press}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref18" id="ftnt18">[18]</a><span class="c2">&nbsp;@inproceedings{jones2000type,</span></p><p class="c3"><span class="c2">&nbsp; title={Type classes with functional dependencies},</span></p><p class="c3"><span class="c2">&nbsp; author={Jones, Mark P},</span></p><p class="c3"><span class="c2">&nbsp; booktitle={European Symposium on Programming},</span></p><p class="c3"><span class="c2">&nbsp; pages={230--244},</span></p><p class="c3"><span class="c2">&nbsp; year={2000},</span></p><p class="c3"><span class="c2">&nbsp; organization={Springer}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref19" id="ftnt19">[19]</a><span class="c2">&nbsp;@article{peyton2006simple,</span></p><p class="c3"><span class="c2">&nbsp; title={Simple unification-based type inference for {GADTs}},</span></p><p class="c3"><span class="c2">&nbsp; author={Peyton Jones, Simon and Vytiniotis, Dimitrios and Weirich, Stephanie and Washburn, Geoffrey},</span></p><p class="c3"><span class="c2">&nbsp; journal={ACM SIGPLAN Notices},</span></p><p class="c3"><span class="c2">&nbsp; volume={41},</span></p><p class="c3"><span class="c2">&nbsp; number={9},</span></p><p class="c3"><span class="c2">&nbsp; pages={50--61},</span></p><p class="c3"><span class="c2">&nbsp; year={2006},</span></p><p class="c3"><span class="c2">&nbsp; publisher={ACM New York, NY, USA}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref20" id="ftnt20">[20]</a><span class="c2">&nbsp;@article{vytiniotis2011outsidein,</span></p><p class="c3"><span class="c2">&nbsp; title={{OutsideIn (X)} Modular type inference with local assumptions},</span></p><p class="c3"><span class="c2">&nbsp; author={Vytiniotis, Dimitrios and Jones, Simon Peyton and Schrijvers, Tom and Sulzmann, Martin},</span></p><p class="c3"><span class="c2">&nbsp; journal={Journal of functional programming},</span></p><p class="c3"><span class="c2">&nbsp; volume={21},</span></p><p class="c3"><span class="c2">&nbsp; number={4-5},</span></p><p class="c3"><span class="c2">&nbsp; pages={333--412},</span></p><p class="c3"><span class="c2">&nbsp; year={2011},</span></p><p class="c3"><span class="c2">&nbsp; publisher={Cambridge University Press}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref21" id="ftnt21">[21]</a><span class="c2">&nbsp;@inproceedings{vytiniotis2010let,</span></p><p class="c3"><span class="c2">&nbsp; title={Let should not be generalized},</span></p><p class="c3"><span class="c2">&nbsp; author={Vytiniotis, Dimitrios and Peyton Jones, Simon and Schrijvers, Tom},</span></p><p class="c3"><span class="c2">&nbsp; booktitle={Proceedings of the 5th ACM SIGPLAN workshop on Types in language design and implementation},</span></p><p class="c3"><span class="c2">&nbsp; pages={39--50},</span></p><p class="c3"><span class="c2">&nbsp; year={2010}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref22" id="ftnt22">[22]</a><span class="c2">&nbsp;@misc{rusthm,</span></p><p class="c3"><span class="c2">&nbsp; author={Matsakis, Nicholas D},</span></p><p class="c3"><span class="c2">&nbsp; title={An experimental new type inference scheme for {Rust}},</span></p><p class="c3"><span class="c2">&nbsp; year={2014},</span></p><p class="c3"><span class="c2">&nbsp; url={http://smallcultfollowing.com/babysteps/blog/2014/07/09/an-experimental-new-type-inference-scheme-for-rust/},</span></p><p class="c3"><span class="c2">&nbsp; note={Accessed 2021-02-27}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref23" id="ftnt23">[23]</a><span class="c2">&nbsp;@misc{rusthm,</span></p><p class="c3"><span class="c2">&nbsp; author={Matsakis, Nicholas D},</span></p><p class="c3"><span class="c2">&nbsp; title={Unification in {Chalk}, part 1},</span></p><p class="c3"><span class="c2">&nbsp; year={2017},</span></p><p class="c3"><span class="c2">&nbsp; url={https://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/},</span></p><p class="c3"><span class="c2">&nbsp; note={Accessed 2021-02-27}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref24" id="ftnt24">[24]</a><span class="c2">&nbsp;@misc{swifthm,</span></p><p class="c3"><span class="c2">&nbsp; author={Gregor, Doug},</span></p><p class="c3"><span class="c2">&nbsp; title={Swift Type Checker Design and Implementation},</span></p><p class="c3"><span class="c2">&nbsp; year={2017},</span></p><p class="c3"><span class="c2">&nbsp; url={https://apple-swift.readthedocs.io/en/latest/TypeChecker.html},</span></p><p class="c3"><span class="c2">&nbsp; note={Accessed 2021-03-19}</span></p></div><div><p class="c3"><a href="#ftnt_ref25" id="ftnt25">[25]</a><span class="c2">&nbsp;@book{gosling2000java,</span></p><p class="c3"><span class="c2">&nbsp; title={The Java language specification},</span></p><p class="c3"><span class="c2">&nbsp; author={Gosling, James and Joy, Bill and Steele, Guy and Bracha, Gilad},</span></p><p class="c3"><span class="c2">&nbsp; year={2000},</span></p><p class="c3"><span class="c2">&nbsp; publisher={Addison-Wesley Professional}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref26" id="ftnt26">[26]</a><span class="c2">&nbsp;@article{milner1978w,</span></p><p class="c3"><span class="c2">&nbsp; title={A theory of type polymorphism in programming},</span></p><p class="c3"><span class="c2">&nbsp; author={Milner, Robin},</span></p><p class="c3"><span class="c2">&nbsp; journal={Journal of computer and system sciences},</span></p><p class="c3"><span class="c2">&nbsp; volume={17},</span></p><p class="c3"><span class="c2">&nbsp; number={3},</span></p><p class="c3"><span class="c2">&nbsp; pages={348--375},</span></p><p class="c3"><span class="c2">&nbsp; year={1978},</span></p><p class="c3"><span class="c2">&nbsp; publisher={Elsevier}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref27" id="ftnt27">[27]</a><span class="c2">&nbsp;@article{lee1998m,</span></p><p class="c3"><span class="c2">&nbsp; title={Proofs about a folklore let-polymorphic type inference algorithm},</span></p><p class="c3"><span class="c2">&nbsp; author={Lee, Oukseh and Yi, Kwangkeun},</span></p><p class="c3"><span class="c2">&nbsp; journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},</span></p><p class="c3"><span class="c2">&nbsp; volume={20},</span></p><p class="c3"><span class="c2">&nbsp; number={4},</span></p><p class="c3"><span class="c2">&nbsp; pages={707--723},</span></p><p class="c3"><span class="c2">&nbsp; year={1998},</span></p><p class="c3"><span class="c2">&nbsp; publisher={ACM New York, NY, USA}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref28" id="ftnt28">[28]</a><span class="c2">&nbsp;@inproceedings{mcadam1998wprime,</span></p><p class="c3"><span class="c2">&nbsp; title={On the unification of substitutions in type inference},</span></p><p class="c3"><span class="c2">&nbsp; author={McAdam, Bruce J},</span></p><p class="c3"><span class="c2">&nbsp; booktitle={Symposium on Implementation and Application of Functional Languages},</span></p><p class="c3"><span class="c2">&nbsp; pages={137--152},</span></p><p class="c3"><span class="c2">&nbsp; year={1998},</span></p><p class="c3"><span class="c2">&nbsp; organization={Springer}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref29" id="ftnt29">[29]</a><span class="c2">&nbsp;@article{robinson1965unification,</span></p><p class="c3"><span class="c2">&nbsp; title={A machine-oriented logic based on the resolution principle},</span></p><p class="c3"><span class="c2">&nbsp; author={Robinson, John Alan},</span></p><p class="c3"><span class="c2">&nbsp; journal={Journal of the ACM (JACM)},</span></p><p class="c3"><span class="c2">&nbsp; volume={12},</span></p><p class="c3"><span class="c2">&nbsp; number={1},</span></p><p class="c3"><span class="c2">&nbsp; pages={23--41},</span></p><p class="c3"><span class="c2">&nbsp; year={1965},</span></p><p class="c3"><span class="c2">&nbsp; publisher={ACM New York, NY, USA}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref30" id="ftnt30">[30]</a><span class="c2">&nbsp;@article{manelli1976unification,</span></p><p class="c3"><span class="c2">&nbsp; title={Unification in Linear Time and Space: A Structured Presentation},</span></p><p class="c3"><span class="c2">&nbsp; author={Manelli, Alberto and Montanari, Ugo},</span></p><p class="c3"><span class="c2">&nbsp; journal={Ist. di Elaborazione delle Informazione, Consiglio Nazionale delle Ricerche, Pisa, Italy},</span></p><p class="c3"><span class="c2">&nbsp; year={1976}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref31" id="ftnt31">[31]</a><span class="c2">&nbsp;@inproceedings{paterson1976linear,</span></p><p class="c3"><span class="c2">&nbsp; title={Linear unification},</span></p><p class="c3"><span class="c2">&nbsp; author={Paterson, Michael S and Wegman, Mark N},</span></p><p class="c3"><span class="c2">&nbsp; booktitle={Proceedings of the eighth annual ACM symposium on Theory of computing},</span></p><p class="c3"><span class="c2">&nbsp; pages={181--186},</span></p><p class="c3"><span class="c2">&nbsp; year={1976}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref32" id="ftnt32">[32]</a><span class="c2">&nbsp;@book{leroy1993caml,</span></p><p class="c3"><span class="c2">&nbsp; title={The Caml Light system, release 0.6: Documentation and user&#39;s manual},</span></p><p class="c3"><span class="c2">&nbsp; author={Leroy, Xavier and Mauny, Michel},</span></p><p class="c3"><span class="c2">&nbsp; year={1993},</span></p><p class="c3"><span class="c2">&nbsp; publisher={Universit{\&#39;e} de Savoie}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref33" id="ftnt33">[33]</a><span class="c2">&nbsp;@article{lee1998m,</span></p><p class="c3"><span class="c2">&nbsp; title={Proofs about a folklore let-polymorphic type inference algorithm},</span></p><p class="c3"><span class="c2">&nbsp; author={Lee, Oukseh and Yi, Kwangkeun},</span></p><p class="c3"><span class="c2">&nbsp; journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},</span></p><p class="c3"><span class="c2">&nbsp; volume={20},</span></p><p class="c3"><span class="c2">&nbsp; number={4},</span></p><p class="c3"><span class="c2">&nbsp; pages={707--723},</span></p><p class="c3"><span class="c2">&nbsp; year={1998},</span></p><p class="c3"><span class="c2">&nbsp; publisher={ACM New York, NY, USA}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref34" id="ftnt34">[34]</a><span class="c2">&nbsp;@misc{swifthm,</span></p><p class="c3"><span class="c2">&nbsp; author={Gregor, Doug},</span></p><p class="c3"><span class="c2">&nbsp; title={Swift Type Checker Design and Implementation},</span></p><p class="c3"><span class="c2">&nbsp; year={2017},</span></p><p class="c3"><span class="c2">&nbsp; url={https://apple-swift.readthedocs.io/en/latest/TypeChecker.html},</span></p><p class="c3"><span class="c2">&nbsp; note={Accessed 2021-03-19}</span></p></div><div><p class="c3"><a href="#ftnt_ref35" id="ftnt35">[35]</a><span class="c2">&nbsp;@book{heeren2005top,</span></p><p class="c3"><span class="c2">&nbsp; title={Top quality type error messages},</span></p><p class="c3"><span class="c2">&nbsp; author={Heeren, Bastiaan J},</span></p><p class="c3"><span class="c2">&nbsp; year={2005},</span></p><p class="c3"><span class="c2">&nbsp; publisher={Utrecht University}</span></p><p class="c3"><span class="c2">}</span></p></div><div><p class="c3"><a href="#ftnt_ref36" id="ftnt36">[36]</a><span class="c21">&nbsp;</span><span class="c20 c21"><a class="c29" href="https://www.google.com/url?q=https://insights.stackoverflow.com/survey/2020%23technology-programming-scripting-and-markup-languages&amp;sa=D&amp;source=editors&amp;ust=1618782946684000&amp;usg=AOvVaw0ZsTx_UBoveNle3LAKO14Y">https://insights.stackoverflow.com/survey/2020</a></span></p></div><div><p class="c3"><a href="#ftnt_ref37" id="ftnt37">[37]</a><span class="c21">&nbsp;</span><span class="c12"><a class="c29" href="https://www.google.com/url?q=https://github.com/mbg/cs310&amp;sa=D&amp;source=editors&amp;ust=1618782946672000&amp;usg=AOvVaw0gQ92Or5XgxHO4f_rYwKGD">https://github.com/mbg/cs310</a></span></p></div></body></html>