<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_n1icddiwhh1h-4{list-style-type:none}.lst-kix_7lyu6nf8ijma-8>li:before{content:"\0025a0  "}.lst-kix_v69dk6nyi3uu-7>li:before{content:"\0025cb  "}ul.lst-kix_n1icddiwhh1h-3{list-style-type:none}ul.lst-kix_n1icddiwhh1h-6{list-style-type:none}.lst-kix_7lyu6nf8ijma-7>li:before{content:"\0025cb  "}ul.lst-kix_v69dk6nyi3uu-1{list-style-type:none}ul.lst-kix_n1icddiwhh1h-5{list-style-type:none}ul.lst-kix_v69dk6nyi3uu-0{list-style-type:none}ul.lst-kix_n1icddiwhh1h-0{list-style-type:none}.lst-kix_7lyu6nf8ijma-6>li:before{content:"\0025cf  "}ul.lst-kix_v69dk6nyi3uu-3{list-style-type:none}ul.lst-kix_v69dk6nyi3uu-2{list-style-type:none}ul.lst-kix_n1icddiwhh1h-2{list-style-type:none}ul.lst-kix_v69dk6nyi3uu-5{list-style-type:none}.lst-kix_v69dk6nyi3uu-8>li:before{content:"\0025a0  "}ul.lst-kix_n1icddiwhh1h-1{list-style-type:none}.lst-kix_v69dk6nyi3uu-4>li:before{content:"\0025cb  "}ul.lst-kix_v69dk6nyi3uu-4{list-style-type:none}.lst-kix_v69dk6nyi3uu-3>li:before{content:"\0025cf  "}ul.lst-kix_n1icddiwhh1h-8{list-style-type:none}ul.lst-kix_n1icddiwhh1h-7{list-style-type:none}.lst-kix_v69dk6nyi3uu-2>li:before{content:"\0025a0  "}.lst-kix_v69dk6nyi3uu-1>li:before{content:"\0025cb  "}.lst-kix_v69dk6nyi3uu-0>li:before{content:"\0025cf  "}ul.lst-kix_v69dk6nyi3uu-7{list-style-type:none}ul.lst-kix_v69dk6nyi3uu-6{list-style-type:none}ul.lst-kix_v69dk6nyi3uu-8{list-style-type:none}.lst-kix_7lyu6nf8ijma-0>li:before{content:"\0025cf  "}.lst-kix_7lyu6nf8ijma-1>li:before{content:"\0025cb  "}.lst-kix_7lyu6nf8ijma-2>li:before{content:"\0025a0  "}.lst-kix_7lyu6nf8ijma-4>li:before{content:"\0025cb  "}.lst-kix_7lyu6nf8ijma-3>li:before{content:"\0025cf  "}.lst-kix_7lyu6nf8ijma-5>li:before{content:"\0025a0  "}.lst-kix_n1icddiwhh1h-0>li:before{content:"\0025cf  "}ul.lst-kix_7lyu6nf8ijma-3{list-style-type:none}ul.lst-kix_7lyu6nf8ijma-4{list-style-type:none}ul.lst-kix_7lyu6nf8ijma-1{list-style-type:none}.lst-kix_n1icddiwhh1h-1>li:before{content:"\0025cb  "}.lst-kix_n1icddiwhh1h-3>li:before{content:"\0025cf  "}ul.lst-kix_7lyu6nf8ijma-2{list-style-type:none}ul.lst-kix_7lyu6nf8ijma-7{list-style-type:none}ul.lst-kix_7lyu6nf8ijma-8{list-style-type:none}ul.lst-kix_7lyu6nf8ijma-5{list-style-type:none}.lst-kix_n1icddiwhh1h-2>li:before{content:"\0025a0  "}ul.lst-kix_7lyu6nf8ijma-6{list-style-type:none}ul.lst-kix_7lyu6nf8ijma-0{list-style-type:none}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_n1icddiwhh1h-5>li:before{content:"\0025a0  "}.lst-kix_n1icddiwhh1h-7>li:before{content:"\0025cb  "}.lst-kix_n1icddiwhh1h-4>li:before{content:"\0025cb  "}.lst-kix_n1icddiwhh1h-8>li:before{content:"\0025a0  "}.lst-kix_v69dk6nyi3uu-5>li:before{content:"\0025a0  "}.lst-kix_v69dk6nyi3uu-6>li:before{content:"\0025cf  "}.lst-kix_n1icddiwhh1h-6>li:before{content:"\0025cf  "}ol{margin:0;padding:0}table td,table th{padding:0}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c14{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c2{padding-top:0pt;padding-bottom:16pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c20{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Arial";font-style:normal}.c18{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c15{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c25{color:#000000;text-decoration:none;vertical-align:baseline;font-size:21pt;font-family:"Arial";font-style:normal}.c23{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c13{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c16{background-color:#ffffff;max-width:451.4pt;padding:72pt 72pt 72pt 72pt}.c22{width:33%;height:1px}.c19{padding:0;margin:0}.c6{margin-left:36pt;padding-left:0pt}.c11{color:inherit;text-decoration:inherit}.c24{background-color:#ffffff;color:#222222}.c12{color:#1155cc;font-size:10pt}.c21{font-weight:700}.c9{font-style:italic}.c8{vertical-align:super}.c17{font-size:10pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c16"><div><p class="c0"><span class="c7"></span></p></div><p class="c18 title" id="h.rl1dsou2c8er"><span class="c21 c25">Interactive Tool for Teaching Hindley-Milner Type Inference through Visualisation</span></p><p class="c2 subtitle" id="h.tjcdwj7drsa5"><span>Final report</span><span><br><br></span><span class="c21">Adam Jones</span><span class="c20"><br>Department of Computer Science<br>University of Warwick</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 341.33px;"><img alt="Screenshot from mbg presentation on structure" src="images/image4.jpg" style="width: 601.70px; height: 341.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">TODO: Abstract, keyword list?</span></p><h1 class="c14" id="h.6k9gcmunzldy"><span class="c10">Introduction</span></h1><p class="c4"><span class="c7">Types in programming languages specify what values an element of a computer program may take. These include primitive data types such as integers, booleans and characters and more complex types such as class or function types.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Programs can be checked for type-errors, either at runtime (dynamic type checking) or compile time (static type checking). Type checking identifies issues with types and throws either runtime or compile errors when an invalid operation has occurred, for example applying a function accepting an integer to a boolean. This is primarily used to catch bugs in program code, preventing unexpected behaviour.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span>Static type checking can prevent type errors from occurring at runtime. This is particularly useful when code paths may not be well-tested or frequently used, as runtime checks only surface type errors when the problematic code is executed. Additionally, static type checking allows for better tooling that improves developer productivity. For example, IDEs may use type information to suggest and perform automated refactorings (</span><sup><a href="#ftnt1" id="ftnt_ref1">[1]</a></sup><span>), automatically generate documentation (</span><sup><a href="#ftnt2" id="ftnt_ref2">[2]</a></sup><span>) and autocomplete statements (</span><sup><a href="#ftnt3" id="ftnt_ref3">[3]</a></sup><span class="c7">).</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Some languages allow the programmer to override static type checking results, in cases where they know more than the type checker about a particular part of a program. For example Java allows casting an object to its subclass and TypeScript has its `as` type assertion operator and `any` and `unknown` types. These can be used sparingly (and often in combination with `instanceof` and `typeof` operators respectively) by programmers as an escape hatch to work around the type checker&rsquo;s limitations. In these situations, runtime checks are often performed to maintain type safety, for example with Java throwing a `ClassCastException`.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">```java</span></p><p class="c4"><span class="c7">// MySubclass extends MyClass</span></p><p class="c4"><span class="c7">// MyOtherSubclass extends MyClass</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">MyClass c1 = new MySubclass();</span></p><p class="c4"><span class="c7">MySubclass s1 = (MySubclass) c1; // okay</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">MyClass c2 = new MyOtherSubclass();</span></p><p class="c4"><span class="c7">MySubclass s2 = (MySubclass) c2; // throws ClassCastException at runtime</span></p><p class="c4"><span class="c7">```</span></p><p class="c4"><span class="c7">Casting an object to its subclass in Java</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">```typescript</span></p><p class="c4"><span class="c7">const a = Math.random() &lt; 0.5 ? &#39;cs310&#39; : 310; // has type &quot;cs310&quot; | 310</span></p><p class="c4"><span class="c7">const b = a + a; // throws a type error, but b could have type &quot;cs310cs310&quot; | 620</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">const c = a == &#39;cs141&#39; ? a + a : a + a; // okay, has type number | string</span></p><p class="c4"><span class="c7">const d = a as any + a; // okay, has type any</span></p><p class="c4"><span class="c7">const e = a as any + a as &#39;cs310cs310&#39; | 620 // okay, has type &quot;cs310cs310&quot; | 620</span></p><p class="c4"><span class="c7">// @ts-ignore</span></p><p class="c4"><span class="c7">const f: &#39;cs310cs310&#39; | 620 = a + a; // okay, has type &quot;cs310cs310&quot; | 620</span></p><p class="c4"><span class="c7">```</span></p><p class="c4"><span class="c7">Some type-safe code is rejected by the TypeScript type checker, but there are many possible workarounds</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">As static type checking is performed at compile time, generally the code must have enough information to deduce its types without runtime arguments. This may be in the form of type annotations or typed variable and function declarations. However, specifying types manually can be time-consuming and potentially difficult.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">A type inference algorithm for a particular programming language&rsquo;s type system can determine types automatically, which improves productivity by allowing programmers to get the best of types without having to explicitly specify them. Because of this, type inference is used in many popular programming languages with expressive type systems including Haskell, Rust and TypeScript.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">An understanding of type inference would help computer scientists write cleaner code and debug type errors. However, few universities have core modules on type systems (although they may be touched on in programming curriculums) and there are limited easy-to-understand teaching resources on type inference. Therefore, many computer science graduates will be missing a useful understanding of how type inference actually works.</span></p><h2 class="c15" id="h.2mwaav7jkal4"><span class="c3">Related work</span></h2><p class="c4"><span>TypeTool by </span><sup><a href="#ftnt4" id="ftnt_ref4">[4]</a></sup><span class="c7">&nbsp;was a tool that visualised type inference through a web application, and was found to be beneficial for teaching purposes. Users entered an expression in a custom expression language, submitted a request to a server and were redirected to a page displaying an initial syntax tree, a final syntax tree and an overall substitution.</span></p><p class="c0"><span class="c7"></span></p><p class="c23"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 462.20px; height: 500.24px;"><img alt="Screenshot of results from TypeTool, taken from their paper" src="images/image2.png" style="width: 462.20px; height: 500.24px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">By allowing users to enter their own expressions, students can explore how the systems work in different cases to gain an intuitive understanding of the concepts. This interactive approach improves understanding as users can easily try testing their own assumptions or examine edge cases they are unsure of.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span>Unfortunately, the tool is now inaccessible as the server hosting the application is no longer running and the source code has not been published. Additionally, as the parsing and type inference was done server-side there was a delay between the user entering an expression and seeing the result. While short, a delay reduces the ease-of-use and may discourage users from trying many different expressions. Both delayed feedback and the lack of step-by-step explanations reduce learning quality (</span><sup><a href="#ftnt5" id="ftnt_ref5">[5]</a></sup><span>), particularly in the area of rule learning; </span><sup><a href="#ftnt6" id="ftnt_ref6">[6]</a></sup><span class="c7">&nbsp;showed that immediate explanatory feedback is most effective at learning how to apply rules in computer programming. It is unclear what the output of the tool with incorrectly-typed expressions is.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Despite these shortcomings, TypeTool&rsquo;s authors found in teaching the University of Porto&rsquo;s functional programming course that the tool was &ldquo;especially useful for students, because it helps to understand the type systems of the most common typed functional languages&rdquo; and that &ldquo;[presenting] the basis of type inference technology [...] significantly improved the way students deal with type errors because they understand the type system.&rdquo;</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><sup><a href="#ftnt7" id="ftnt_ref7">[7]</a></sup><span class="c7">&nbsp;developed a visual functional programming system which visualises types during function application for a subset of Standard ML, used to teach first year undergraduate students. However, this did not explicitly show the type inference process and as a desktop application rather than web app it is less accessible to lecturers and students. It also didn&rsquo;t support key functional language constructs such as function declarations and let bindings, and required significant explanation before using the tool to understand its output.</span></p><p class="c0"><span class="c7"></span></p><p class="c23"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 478.20px; height: 299.47px;"><img alt="Screenshot of Yung and Michaelson&#39;s tool, taken from their paper" src="images/image1.png" style="width: 478.20px; height: 299.47px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span>NiMo (</span><sup><a href="#ftnt8" id="ftnt_ref8">[8]</a></sup><span class="c7">) is a graphical programming language related to functional data processing which allows users to reason about the flow of data through a program. The types of data and processes can be inspected in NiMoToons, and type inference is performed over the network of components. However, larger expressions can become complicated and be difficult to interpret. While NiMo performs type inference internally it is not a key focus to the end-user, and as such does not explain its steps. Additionally, it is harder to relate back to more commonly used, textual functional languages like Haskell.</span></p><p class="c0"><span class="c7"></span></p><p class="c23"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 576.24px; height: 192.40px;"><img alt="A diagram showing the types of some variables in NiMo, taken from their paper" src="images/image3.png" style="width: 576.24px; height: 192.40px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c7"></span></p><p class="c4"><sup><a href="#ftnt9" id="ftnt_ref9">[9]</a></sup><span class="c7">&nbsp;implemented a successful teaching tool, named TILC, for visualising lambda-calculus parse trees in order to help with teaching lambda-calculus to undergraduate students. They noted that to develop an intuitive understanding, students would benefit from &nbsp;experimenting with lambda-calculus and that &ldquo;a tool that deals with all these aspects in a friendly and graphical manner incentivises [experimentation]&rdquo;. TILC was successful, with the module organisers of &lsquo;programming paradigms&rsquo; at the Universitat de Girona having a &ldquo;good experience of using this tool in the course lectures and as a downloadable tool for students&rdquo;. The authors suggested extending TILC to show types and type inference would have pedagogical value.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span>To summarise, types (such as integers, booleans and functions) aid the construction of correct programs. Type checking can detect errors in programs, called </span><span class="c9">static</span><span>&nbsp;when run at compilation time and </span><span class="c9">dynamic</span><span class="c7">&nbsp;if run as the program executes. Type inference is a method often used alongside static type checking to determine types in a program, an understanding of which could benefit computer scientists in writing and debugging programs. Some solutions exist which give students a better idea about types, however they either have significant limitations or do not explicitly cover type inference.</span></p><h2 class="c15" id="h.o72kh3tf0r5l"><span class="c3">Objectives</span></h2><p class="c4"><span class="c7">The ultimate goal of the project is to improve undergraduate students&rsquo; knowledge and understanding of how type inference works.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">To achieve this, this project will develop a teaching resource that explains how type inference algorithms work for functional languages. An interactive web application will allow students to enter expressions and view the results of a type inference algorithm, along with the steps taken to get to that result. This would be particularly useful in the context of modules teaching functional languages such as Haskell which perform similar type inference.</span></p><h1 class="c14" id="h.ebjyqi73zdyo"><span class="c10">Background</span></h1><h2 class="c15" id="h.odw4vku9eizz"><span class="c3">&lambda;-calculus</span></h2><p class="c4"><span class="c7">A &lambda;-calculus is a representation of computation. Generally these have at least 3 key constructs:</span></p><ul class="c19 lst-kix_v69dk6nyi3uu-0 start"><li class="c4 c6 li-bullet-0"><span class="c7">`var`: Variables</span></li><li class="c4 c6 li-bullet-0"><span class="c7">`abs`: Function abstraction, defining anonymous functions</span></li><li class="c4 c6 li-bullet-0"><span class="c7">`app`: Function application, applying subexpressions to each other</span></li></ul><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">For example, consider the expression:</span></p><p class="c4"><span class="c7">```</span></p><p class="c4"><span class="c7">(&lambda;x. x) y</span></p><p class="c4"><span class="c7">```</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">It has variables `x` and `y`. Variables may be bound or free (unbound). Here `x` is bound as it is a parameter in the function abstraction, and `y` is free as there is nothing which binds it. This can be thought of in a similar way to how variables in most imperative programming languages have a scope where they are defined or undefined.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span>The function abstraction mentioned is the `&lambda;x. x` part. This defines an anonymous function </span><span>which given</span><span class="c7">&nbsp;an argument (before the full stop) `x` simply returns (after the full stop) `x`, i.e. the identity function. A function to add three to an input might be written `&lambda;x. x + 3` (although many of the most fundamental &lambda;-calculi do not have such explicit notions of addition or numbers).</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Functions may be returned by other functions, which enables functions to have the appearance of taking multiple arguments. For example `&lambda;x. (&lambda;y. x)` can be viewed as a function which takes two arguments and then returns the first one. Here explicit brackets have been given for clarity, but they aren&rsquo;t necessary. Additionally, sometimes multiple arguments like this are written together, so `&lambda;x. (&lambda;y. x)`, `&lambda;x. &lambda;y. x` and `&lambda;xy. x` all mean the same thing.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Finally, the function application is actually applying the function `&lambda;x. x` to the argument `y`. In &lambda;-calculus evaluation is performed via &beta;-reductions. In our example this could be done by substituting the argument `y` for parameter `x` in the body of the function `x`, resulting in `y`.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">This expression&rsquo;s construction can be represented as an abstract syntax tree:</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">TODO: tree diagram of the expression</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">In addition to these three constructs, a `let` construct is added to some calculi to allow binding a value to a variable in an expression. For example `let x = 3 in x * x` binds `x` to the value `3` in `x * x`. A `lit` construct may be added to represent literal constants, such as numbers or booleans like `3` and `True`.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">&lambda;-calculi have been extensively studied, often using formal inductive definitions. For example, the inductive definition for the set of free variables in an expression based on the constructors introduced so far is:</span></p><ul class="c19 lst-kix_n1icddiwhh1h-0 start"><li class="c4 c6 li-bullet-0"><span class="c7">`var`: $FV(x) = { x }$</span></li><li class="c4 c6 li-bullet-0"><span class="c7">`abs`: $FV(&lambda;x. E) = FV(E) - { x }$</span></li><li class="c4 c6 li-bullet-0"><span class="c7">`app`: $FV(E_1 E_2) = FV(E_1) &cup; FV(E_2)$</span></li><li class="c4 c6 li-bullet-0"><span class="c7">`let`: $FV(let x = E_1 in E_2) = FV(E_2) - { x }$</span></li><li class="c4 c6 li-bullet-0"><span class="c7">`lit`: $FV(c) = &empty;$</span></li></ul><p class="c4"><span class="c7">where E is any expression. Given these rules the set of free variables for any combination of these constructs can be determined. This can be demonstrated for our example expression `(&lambda;x. x) y`, which is shown in a tree structure below. More generally this is an example of how an inductive definition can tell us something about the entire program which is how some type inference algorithms can be viewed.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">TODO: tree diagram of the expression with the sets of free variables at each node.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Most real-world environments define a context which binds some variables by default to in-built values. For example Haskell&rsquo;s GHC primitives and Prelude includes basic variables like `[]` (the empty list) and `not` (a function which inverts booleans). These can be considered bound at the top level and removed from the set of free variables there.</span></p><h2 class="c15" id="h.w7vj0r89b86n"><span class="c3">The simply typed &lambda;-calculus</span></h2><p class="c4"><span>Typed </span><span class="c7">&lambda;-calculi extend the system with the concept of types.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span>The simply typed &lambda;-calculus is one of the simplest typed &lambda;-calculi, and introduced by </span><sup><a href="#ftnt10" id="ftnt_ref10">[10]</a></sup><span>&nbsp;is often viewed as the canonical typed &lambda;-calculus. It has the `var`, `abs`, `app` and `lit` constructs. Types in this system are either base types (often in the literature Greek letters &alpha;, &beta;, &gamma; are used, but these can be thought of similar to numbers, booleans, characters etc.) or functions between other types (such as `Int -&gt; Bool`, or `Int -&gt; (Bool -&gt; Bool)`). The syntax is modified to add type annotations to `var`, `abs` and `lit` constructs, for example `(&lambda;x: Int. odd</span><span class="c8">Int -&gt; Bool</span><span>&nbsp;</span><span>x</span><span class="c8">Int</span><span>) 3</span><span class="c8">Int</span><span class="c7">` (although often for simplicity the types of `var` and `lit` subexpressions, those in superscript, are left out).</span></p><h2 class="c15" id="h.gsouq2axz3k"><span class="c3">Hindley-Milner type system</span></h2><p class="c4"><span>Hindley-Milner (HM) is a typed &lambda;-calculus which allows for the types of programs to be inferred and no type annotations are required (</span><sup><a href="#ftnt11" id="ftnt_ref11">[11]</a></sup><sup><a href="#ftnt12" id="ftnt_ref12">[12]</a></sup><span>). It extends the simply typed &lambda;-calculus by adding `let` bindings and a richer type system that includes </span><span class="c9">type functions</span><span>&nbsp;and </span><span class="c9">polymorphism</span><span class="c7">.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Like expressions, types can be considered to be built from `var` variables and `app` function applications. Type variables are either base types like `Bool` and `Int` or type functions. Type functions can be applied, taking types as parameters to construct composite types. For a type to be valid all functions must be fully applied, unlike expressions where the final expression may be a function. &nbsp;As with expressions, we can again assume a global context that binds the basics like `Bool`, `Int` and `-&gt;`. In Hindley&rsquo;s original paper only `-&gt;` was considered as a type function, however here we explore several type functions that have been found useful in practice.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">The type function we&rsquo;ve already been using is the function type function, `-&gt;`. It takes two types as arguments and represents a function from the first type to the second. A function from `Int` to `Bool` is represented by `(-&gt;) Bool Int` in prefix notation, although would more commonly be written infix as `Bool -&gt; Int`. The function type function (`-&gt;`) should not be confused with the function type: an expression representing a function has a function type, and that function type is the function type function applied to arguments. For example `&lambda;x. x + 3` has a function type `Int -&gt; Int`, which is the function type function `-&gt;` applied to arguments `Int` and `Int`.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">The list type function is also very common, which given one type argument represents a list of those types. A list of booleans might be written `List Bool` or `[] Bool` in prefix notation, although often the list type is represented by wrapping the type argument in square brackets instead like `[Bool]`.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span>`Maybe` is another type function commonly used in functional languages like Haskell. A `Maybe` represents the optional presence of something, similar to </span><span>Java&rsquo;s</span><span class="c7">&nbsp;`Optional` and C++&rsquo;s `std::optional`. Applied to a boolean type this may be written `Maybe Bool`, representing a wrapper around nothing or a boolean. In Java this would be represented with a generic as `Optional&lt;Boolean&gt;` and in C++ `std::optional&lt;bool&gt;`.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Other common type functions include `Either` and tuples. `Either` takes two type arguments and represents a wrapper around either one of the types, e.g. an either for a boolean or integer is written `Either Bool Int`. Tuple constructors are a set of type functions representing a cross product of their type arguments, named `,`, `,,`, `,,,` and so on for different element lengths. A 3-tuple holding a boolean, integer and integer can technically be written in prefix notation as `(,,) Bool Int Int` but instead generally tuples borrow mathematical syntax with parentheses and commas like `(Bool, Int, Int)`.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">The set of types made from `var` and `app` are known as monotypes. For example, `Bool`, `Int`, `Bool -&gt; Int`, and `Bool -&gt; [(Bool, Int -&gt; Maybe Bool)]` are all monotypes.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Adding zero or more for-all qualified type variables to monotypes forms polytypes (called principal type schemes by Hindley and polymorphic types by Milner). This can be thought of as the `abs` equivalent for types, written as `&forall;x. &rho;` where `&rho;` is a polytype. This definition makes monotypes a special case of polytypes: monotypes are polytypes with zero for-all qualified type variables.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span>Polytypes allow for parametric polymorphism, where a type may be parameterized by a for-all bound quantifier. This allows functions to accept different types as long as they meet certain constraints. For example the `length` function is polymorphic: it has the polytype `</span><span>&forall;x. [x] -&gt; Int</span><span class="c7">`, which accepts a list of any type and returns its length as an integer. It accepts different types such as `[Bool]` and `[Int -&gt; Bool]` as both of these meet the constraint of being a list.</span></p><p class="c4"><span>Correctly inferring polymorphic types can be difficult, and in fact </span><sup><a href="#ftnt13" id="ftnt_ref13">[13]</a></sup><span class="c7">&nbsp;proved that doing so for System F, a type system similar to Hindley-Milner with fewer typing rule constraints, is undecidable. To avoid this, HM chooses not always generalise to the most generic type in function abstraction [TODO: why not treat them like let bindings and institate them with a for-all qualifier?]. As a workaround, it adds `let` bindings which allows for binding variables to values with polymorphic types explicitly by generalising the type of the bound variable.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">This is the difference between:</span></p><ul class="c19 lst-kix_7lyu6nf8ijma-0 start"><li class="c4 c6 li-bullet-0"><span class="c7">`let i = (\x -&gt; x) in (i 3, i True)` type-checks, as i is generalised to the polytype `&forall;a. a -&gt; a` so can be applied to both an `Int` and `Bool`</span></li><li class="c4 c6 li-bullet-0"><span class="c7">`(\i -&gt; (i 3, i True)) (\x -&gt; x)` does not type-check as i has the monotype `a -&gt; a`, and `a` must take only one type in both tuple parts.</span></li></ul><p class="c0"><span class="c7"></span></p><p class="c4"><span>Hindley-Milner is the basis for the type system of Standard ML (</span><sup><a href="#ftnt14" id="ftnt_ref14">[14]</a></sup><span>) (which OCaml and F# are related to) and was the basis of the type system in Haskell (</span><sup><a href="#ftnt15" id="ftnt_ref15">[15]</a></sup><span class="c7">).</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/&amp;sa=D&amp;source=editors&amp;ust=1613332984312000&amp;usg=AOvVaw32dbpTvC5mj-Ooy0U9CDlv">http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/</a></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://perplexinglyemma.blogspot.com/2017/06/language-servers-and-ides.html&amp;sa=D&amp;source=editors&amp;ust=1613332984313000&amp;usg=AOvVaw2ei9zdkBuS6jIte6SoRhUS">https://perplexinglyemma.blogspot.com/2017/06/language-servers-and-ides.html</a></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://www.reddit.com/r/rust/comments/6fs5q9/language_servers_and_ides/dikywtc/&amp;sa=D&amp;source=editors&amp;ust=1613332984314000&amp;usg=AOvVaw3jVM1VS7GAafxzYbS38jLQ">https://www.reddit.com/r/rust/comments/6fs5q9/language_servers_and_ides/dikywtc/</a></span></p><p class="c4"><span class="c7">Looks maybe useful - talks about unification and type inference, although from a fairly Rust-y perspective (and I&rsquo;ve never touched Rust before&hellip;)</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://apple-swift.readthedocs.io/en/latest/TypeChecker.html&amp;sa=D&amp;source=editors&amp;ust=1613332984315000&amp;usg=AOvVaw3iUZxMoP15G6ZjxYNrwM5P">https://apple-swift.readthedocs.io/en/latest/TypeChecker.html</a></span></p><p class="c4"><span class="c7">&ldquo;Swift implements bi-directional type inference using a constraint-based type checker that is reminiscent of the classical Hindley-Milner type inference algorithm.&rdquo; ... &ldquo;The Swift language contains a number of features not part of the Hindley-Milner type system, including constrained polymorphic types and function overloading&rdquo;.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span>Haskell has since been extended with type-class constraints (</span><sup><a href="#ftnt16" id="ftnt_ref16">[16]</a></sup><span>), functional dependencies (</span><sup><a href="#ftnt17" id="ftnt_ref17">[17]</a></sup><span>), and generalised algebraic data types (GADTs) (</span><sup><a href="#ftnt18" id="ftnt_ref18">[18]</a></sup><span>). Haskell&rsquo;s inference engine was moved onto a new engine, OutsideIn(X), when GHC 7.2 was released November 2011 after </span><sup><a href="#ftnt19" id="ftnt_ref19">[19]</a></sup><span>&nbsp;proposed a solution to the issues with Hindley-Milner&rsquo;s poor performance on large programs and difficulty inferring expressions without principal types that arise with type-class constraints and GADTs. In doing this, Haskell stopped automatically generalising variables bound by `let` expressions after </span><sup><a href="#ftnt20" id="ftnt_ref20">[20]</a></sup><span class="c7">&nbsp;argued that generalising `let` bindings is complex in type inference engines other than HM and the feature was rarely used in practice, with the change only affecting 0.13% lines of the GHC core libraries.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">For the purposes of the teaching tool HM gives a good representation of how type inference works to students while not being too complex to understand, and is related to how languages commonly used in practice perform type inference.</span></p><h2 class="c15" id="h.admfqf7bhkct"><span class="c3">Hindley-Milner type inference</span></h2><p class="c4"><span>Various algorithms are available to infer types in Hindley-Milner such as Algorithm W by </span><sup><a href="#ftnt21" id="ftnt_ref21">[21]</a></sup><span>&nbsp;and Algorithm M by </span><sup><a href="#ftnt22" id="ftnt_ref22">[22]</a></sup><span class="c7">. Algorithm W takes a bottom-up approach, attempting to unify the types of subexpressions up the abstract syntax tree, while Algorithm M takes a top-down approach, unifying types down the tree.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span>Both algorithms sometimes produce poor type error messages; Algorithm W often detects errors late, highlighting too large of a subexpression to be useful and Algorithm M often detects too specific of a term without context as to what original definition it violates. Because of this, hybrid or constraint-based algorithms along with heuristics are often used in practice to provide more informative error messages. Additionally, despite not being required, explicit type annotations are often used to help identify errors earlier at locations which are easier to interpret (</span><sup><a href="#ftnt23" id="ftnt_ref23">[23]</a></sup><span class="c7">). Type annotations can also act as documentation to future programmers using or working on the code, as sometimes the most general type as worked out by a type inference algorithm may not convey the intent of the programmer most clearly.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">TODO: substitutions, contexts, unification</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">TODO: typing rules</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">TODO: algorithm W and M definitions?</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://aaltodoc.aalto.fi/bitstream/handle/123456789/42719/master_Mikkonen_Juuso_2020.pdf&amp;sa=D&amp;source=editors&amp;ust=1613332984317000&amp;usg=AOvVaw2zvSjzHqx8KdJotwyrijR4">https://aaltodoc.aalto.fi/bitstream/handle/123456789/42719/master_Mikkonen_Juuso_2020.pdf</a></span></p><p class="c4"><span class="c7">Talks about statically typed languages in JavaScript-land. Mentions things like TypeScript don&rsquo;t use HM because JS has a lot of structural typing (i.e. if objects have the right properties it&rsquo;s fine to call methods that depend on that interface) and subtyping.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://research.cs.queensu.ca/home/jana/papers/bidir/Dunfield13_bidir.pdf&amp;sa=D&amp;source=editors&amp;ust=1613332984318000&amp;usg=AOvVaw1pbMKfszissxKFM2YmoVOg">https://research.cs.queensu.ca/home/jana/papers/bidir/Dunfield13_bidir.pdf</a></span></p><p class="c4"><span class="c7">I seem to have come across this paper quite a few times. I still don&rsquo;t really understand it, but it seems important.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://www.sigmacomputing.com/blog/writing-a-parser-combinator-from-scratch-in-typescript/&amp;sa=D&amp;source=editors&amp;ust=1613332984318000&amp;usg=AOvVaw0gCSLWTF4_TB8NVp-hH3M6">https://www.sigmacomputing.com/blog/writing-a-parser-combinator-from-scratch-in-typescript/</a></span></p><p class="c4"><span class="c7">Parser in TypeScript</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://tomassetti.me/parsing-in-javascript/&amp;sa=D&amp;source=editors&amp;ust=1613332984319000&amp;usg=AOvVaw1pyILvOgIi4Wz_T1eUcnbD">https://tomassetti.me/parsing-in-javascript/</a></span></p><p class="c4"><span class="c7">Parsing in JavaScript - lots of library recommendations (see Parjs and Jison)</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=http://reasonableapproximation.net/2019/05/05/hindley-milner.html&amp;sa=D&amp;source=editors&amp;ust=1613332984319000&amp;usg=AOvVaw28fKq55oISz6BjrZN1j7g1">http://reasonableapproximation.net/2019/05/05/hindley-milner.html</a></span></p><p class="c4"><span class="c7">A reckless introduction to Hindley-Milner type inference</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Types_and_Programming_Languages&amp;sa=D&amp;source=editors&amp;ust=1613332984320000&amp;usg=AOvVaw3QXG8kDPUhzy-ngTuakFoJ">https://en.wikipedia.org/wiki/Types_and_Programming_Languages</a></span></p><p class="c4"><span class="c7">Book recommended by mbg</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/milner-type-polymorphism.pdf&amp;sa=D&amp;source=editors&amp;ust=1613332984320000&amp;usg=AOvVaw1lkvDyEVT4fVwd4jp0DLLL">https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/milner-type-polymorphism.pdf</a></span></p><p class="c4"><span class="c7">Original algorithm W paper</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://www.dcs.warwick.ac.uk/michael_gale/publications/wsiw.pdf&amp;sa=D&amp;source=editors&amp;ust=1613332984321000&amp;usg=AOvVaw0R_67u_QgDUkfXLFNpZ5hu">https://www.dcs.warwick.ac.uk/michael_gale/publications/wsiw.pdf</a></span></p><p class="c4"><span class="c7">Michael&rsquo;s what should I wear paper</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=http://citeseerx.ist.psu.edu/viewdoc/download?doi%3D10.1.1.65.7733%26rep%3Drep1%26type%3Dpdf&amp;sa=D&amp;source=editors&amp;ust=1613332984322000&amp;usg=AOvVaw0U5Ir3p_zhWtuE8dzeIXLN">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.7733&amp;rep=rep1&amp;type=pdf</a></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://gist.github.com/paf31/a49a54d7ea5ede43422f&amp;sa=D&amp;source=editors&amp;ust=1613332984322000&amp;usg=AOvVaw31P_QV-zs5iOaSstXDMjWp">https://gist.github.com/paf31/a49a54d7ea5ede43422f</a></span></p><p class="c4"><span class="c7">Implementing algorithm W in Haskell</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://codeburst.io/https-chidume-nnamdi-com-npm-module-in-typescript-12b3b22f0724&amp;sa=D&amp;source=editors&amp;ust=1613332984323000&amp;usg=AOvVaw0E8SVSwjCsB3OwXxMrpgGp">https://codeburst.io/https-chidume-nnamdi-com-npm-module-in-typescript-12b3b22f0724</a></span></p><p class="c4"><span class="c7">Typescript library template</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://www.researchgate.net/profile/Jurriaan_Hage/publication/221241370_Scripting_the_Type_Inference_Process/links/02e7e51a37f9233c65000000.pdf&amp;sa=D&amp;source=editors&amp;ust=1613332984324000&amp;usg=AOvVaw0faLpk_fsWhyHwep1JsSCN">https://www.researchgate.net/profile/Jurriaan_Hage/publication/221241370_Scripting_the_Type_Inference_Process/links/02e7e51a37f9233c65000000.pdf</a></span></p><p class="c4"><span class="c7">Improving type error messages</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://dspace.library.uu.nl/bitstream/handle/1874/7297/full.pdf?sequence%3D8&amp;sa=D&amp;source=editors&amp;ust=1613332984324000&amp;usg=AOvVaw0sNEFDh6n5ijAK9jjzyau9">https://dspace.library.uu.nl/bitstream/handle/1874/7297/full.pdf?sequence=8</a></span></p><p class="c4"><span class="c7">Top quality type error messages</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://manu.sridharan.net/files/mycroft-preprint.pdf&amp;sa=D&amp;source=editors&amp;ust=1613332984325000&amp;usg=AOvVaw1xkuvValyToieLNJ3S8o9e">https://manu.sridharan.net/files/mycroft-preprint.pdf</a></span></p><p class="c4"><span class="c7">A Practical Framework for Type Inference Error Explanation</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://theory.stanford.edu/~aiken/publications/trs/FLProject.pdf&amp;sa=D&amp;source=editors&amp;ust=1613332984326000&amp;usg=AOvVaw3m9S-OynrWSAXe1k7BkurN">https://theory.stanford.edu/~aiken/publications/trs/FLProject.pdf</a></span></p><p class="c4"><span class="c7">Designing a FP language</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=http://citeseerx.ist.psu.edu/viewdoc/download?doi%3D10.1.1.110.5050%26rep%3Drep1%26type%3Dpdf&amp;sa=D&amp;source=editors&amp;ust=1613332984326000&amp;usg=AOvVaw2zGV19XQjH_Pxmeu3MEBdE">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.110.5050&amp;rep=rep1&amp;type=pdf</a></span></p><p class="c4"><span class="c7">PhD thesis which talks about hindley milner and type inference a lot</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=http://www.reflection.uniovi.es/ortin/publications/visual-2014.pdf&amp;sa=D&amp;source=editors&amp;ust=1613332984327000&amp;usg=AOvVaw1LTCxBOwG9jGdOZldbdQNX">http://www.reflection.uniovi.es/ortin/publications/visual-2014.pdf</a></span></p><p class="c4"><span class="c7">Hybrid dynamically and statically typed languages</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=http://lucacardelli.name/papers/typesystems.pdf&amp;sa=D&amp;source=editors&amp;ust=1613332984327000&amp;usg=AOvVaw3cAkh1l8gOg8-C_53WnnLG">http://lucacardelli.name/papers/typesystems.pdf</a></span></p><p class="c4"><span class="c7">Paper that introduces the basics of type systems and types n&rsquo; stuff</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c13"><a class="c11" href="https://www.google.com/url?q=https://citeseerx.ist.psu.edu/viewdoc/download?doi%3D10.1.1.5.4267%26rep%3Drep1%26type%3Dpdf&amp;sa=D&amp;source=editors&amp;ust=1613332984328000&amp;usg=AOvVaw34k8lXlnoc8zGQoxMNSnVf">https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.5.4267&amp;rep=rep1&amp;type=pdf</a></span></p><p class="c4"><span class="c7">Algorithm W&rsquo;, the symmetric unification one</span></p><p class="c0"><span class="c7"></span></p><h1 class="c14" id="h.7ggvdxb04tzm"><span class="c10">Design</span></h1><p class="c4"><span class="c7">???</span></p><h1 class="c14" id="h.igepudpadp49"><span class="c10">Implementation</span></h1><p class="c4"><span class="c7">Developed gdoc2latex</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Set up CI system to build latex docs</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Tried using Docker to run latex compilation step in GitHub actions, but found it was significantly slower (2 mins vs 45 seconds) than installing texlive-latex-extra and texlive-bibtex-extra on the runner directly.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Implemented algorithm W in a mix of class-based and functions, then reimplemented to be just functions.</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Added custom test matcher</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">How the step logging works</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">How does the web app work, performance analysis and considerations</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Analytics</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Adding algorithm M</span></p><h1 class="c14" id="h.e6letww4nhn0"><span class="c10">Evaluation</span></h1><p class="c4"><span class="c7">Maybe also analyse performance?</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span>Compare</span><span class="c7">&nbsp;to existing available libraries?</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Test on people?</span></p><p class="c0"><span class="c7"></span></p><p class="c4"><span class="c7">Look at the analytics?</span></p><h1 class="c14" id="h.fc67ipatea73"><span class="c10">Conclusions and Further Work</span></h1><p class="c0"><span class="c7"></span></p><h1 class="c14" id="h.i0n8c6hqdr6j"><span class="c10">Ethics</span></h1><p class="c0"><span class="c7"></span></p><h1 class="c14" id="h.xqaef57orpsv"><span class="c10">Acknowledgements</span></h1><p class="c4"><span>This document was typeset using a derivative of the CS310 starter pack</span><sup><a href="#ftnt24" id="ftnt_ref24">[24]</a></sup><span class="c7">&nbsp;by Michael Gale, licensed under CC BY 4.0.</span></p><hr class="c22"><div><p class="c1"><a href="#ftnt_ref1" id="ftnt1">[1]</a><span class="c5">&nbsp;@inproceedings{li2003tool,</span></p><p class="c1"><span class="c5">&nbsp; title={Tool support for refactoring functional programs},</span></p><p class="c1"><span class="c5">&nbsp; author={Li, Huiqing and Reinke, Claus and Thompson, Simon},</span></p><p class="c1"><span class="c17">&nbsp; </span><span class="c17">booktitle</span><span class="c5">={Proceedings of the 2003 ACM SIGPLAN workshop on Haskell},</span></p><p class="c1"><span class="c5">&nbsp; pages={27--38},</span></p><p class="c1"><span class="c5">&nbsp; year={2003}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref2" id="ftnt2">[2]</a><span class="c5">&nbsp;@article{hobmaierimproving,</span></p><p class="c1"><span class="c5">&nbsp; title={Improving the Quality of OpenAPI Specifications Using TypeScript Types and Annotations},</span></p><p class="c1"><span class="c5">&nbsp; author={Hobmaier, Wolfgang}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref3" id="ftnt3">[3]</a><span class="c5">&nbsp;@inproceedings{asaduzzaman2015exploring,</span></p><p class="c1"><span class="c5">&nbsp; title={Exploring API method parameter recommendations},</span></p><p class="c1"><span class="c5">&nbsp; author={Asaduzzaman, Muhammad and Roy, Chanchal K and Monir, Samiul and Schneider, Kevin A},</span></p><p class="c1"><span class="c5">&nbsp; booktitle={2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)},</span></p><p class="c1"><span class="c5">&nbsp; pages={271--280},</span></p><p class="c1"><span class="c5">&nbsp; year={2015},</span></p><p class="c1"><span class="c5">&nbsp; organization={IEEE}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref4" id="ftnt4">[4]</a><span class="c5">&nbsp;@inproceedings{simoes2004typetool,</span></p><p class="c1"><span class="c5">&nbsp; title={TypeTool: A type inference visualization tool},</span></p><p class="c1"><span class="c17">&nbsp; author={Simoes, Hugo and Florido, M</span><span class="c17 c24">&aacute;</span><span class="c5">rio},</span></p><p class="c1"><span class="c17">&nbsp; </span><span class="c17">booktitle</span><span class="c5">={WFLP&rsquo;04: Proc. 13th Intl. Workshop on Functional and (Constraint) Logic Programming, H. Kuchen, Ed. RWTH Aachen, Dept. Comp. Sc., Technical report AIB-2004-05},</span></p><p class="c1"><span class="c5">&nbsp; pages={48--61},</span></p><p class="c1"><span class="c5">&nbsp; year={2004},</span></p><p class="c1"><span class="c5">&nbsp; organization={Citeseer}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref5" id="ftnt5">[5]</a><span class="c5">&nbsp;@article{mory2004feedback,</span></p><p class="c1"><span class="c5">&nbsp; title={Feedback research revisited.},</span></p><p class="c1"><span class="c5">&nbsp; author={Mory, Edna Holland},</span></p><p class="c1"><span class="c5">&nbsp; year={2004},</span></p><p class="c1"><span class="c5">&nbsp; publisher={Lawrence Erlbaum Associates Publishers}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref6" id="ftnt6">[6]</a><span class="c5">&nbsp;@article{lee1989effects,</span></p><p class="c1"><span class="c5">&nbsp; title={The effects of feedback and second try in computer-assisted instruction for rule-learning task},</span></p><p class="c1"><span class="c5">&nbsp; author={Lee, Doris},</span></p><p class="c1"><span class="c5">&nbsp; year={1989}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref7" id="ftnt7">[7]</a><span class="c5">&nbsp;@article{jung2000visualisation,</span></p><p class="c1"><span class="c5">&nbsp; title={A visualisation of polymorphic type checking},</span></p><p class="c1"><span class="c5">&nbsp; author={Jung, Yang and Michaelson, Greg},</span></p><p class="c1"><span class="c5">&nbsp; journal={Journal of Functional Programming},</span></p><p class="c1"><span class="c5">&nbsp; volume={10},</span></p><p class="c1"><span class="c5">&nbsp; number={1},</span></p><p class="c1"><span class="c5">&nbsp; pages={57--75},</span></p><p class="c1"><span class="c5">&nbsp; year={2000}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref8" id="ftnt8">[8]</a><span class="c5">&nbsp;@article{clerici2009nimotoons,</span></p><p class="c1"><span class="c5">&nbsp; title={Nimotoons: a totally graphic workbench for program tuning and experimentation},</span></p><p class="c1"><span class="c5">&nbsp; author={Clerici, Silvia and Zoltan, Cristina and Prestigiacomo, Guillermo},</span></p><p class="c1"><span class="c5">&nbsp; journal={Electronic Notes in Theoretical Computer Science},</span></p><p class="c1"><span class="c5">&nbsp; volume={258},</span></p><p class="c1"><span class="c5">&nbsp; number={1},</span></p><p class="c1"><span class="c5">&nbsp; pages={93--107},</span></p><p class="c1"><span class="c5">&nbsp; year={2009},</span></p><p class="c1"><span class="c5">&nbsp; publisher={Elsevier}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref9" id="ftnt9">[9]</a><span class="c5">&nbsp;@article{ruiz2009tilc,</span></p><p class="c1"><span class="c5">&nbsp; title={TILC: The interactive lambda-calculus tracer},</span></p><p class="c1"><span class="c5">&nbsp; author={Ruiz, David and Villaret, Mateu},</span></p><p class="c1"><span class="c5">&nbsp; journal={Electronic Notes in Theoretical Computer Science},</span></p><p class="c1"><span class="c5">&nbsp; volume={248},</span></p><p class="c1"><span class="c5">&nbsp; pages={173--183},</span></p><p class="c1"><span class="c5">&nbsp; year={2009},</span></p><p class="c1"><span class="c5">&nbsp; publisher={Elsevier}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref10" id="ftnt10">[10]</a><span class="c5">&nbsp;@article{church1940formulation,</span></p><p class="c1"><span class="c5">&nbsp; title={A formulation of the simple theory of types},</span></p><p class="c1"><span class="c5">&nbsp; author={Church, Alonzo},</span></p><p class="c1"><span class="c5">&nbsp; journal={The journal of symbolic logic},</span></p><p class="c1"><span class="c5">&nbsp; volume={5},</span></p><p class="c1"><span class="c5">&nbsp; number={2},</span></p><p class="c1"><span class="c5">&nbsp; pages={56--68},</span></p><p class="c1"><span class="c5">&nbsp; year={1940},</span></p><p class="c1"><span class="c5">&nbsp; publisher={JSTOR}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref11" id="ftnt11">[11]</a><span class="c5">&nbsp;@article{hindley1969principal,</span></p><p class="c1"><span class="c5">&nbsp; title={The principal type-scheme of an object in combinatory logic},</span></p><p class="c1"><span class="c5">&nbsp; author={Hindley, Roger},</span></p><p class="c1"><span class="c5">&nbsp; journal={Transactions of the american mathematical society},</span></p><p class="c1"><span class="c5">&nbsp; volume={146},</span></p><p class="c1"><span class="c5">&nbsp; pages={29--60},</span></p><p class="c1"><span class="c5">&nbsp; year={1969},</span></p><p class="c1"><span class="c5">&nbsp; publisher={JSTOR}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref12" id="ftnt12">[12]</a><span class="c5">&nbsp;@article{milner1978theory,</span></p><p class="c1"><span class="c5">&nbsp; title={A theory of type polymorphism in programming},</span></p><p class="c1"><span class="c5">&nbsp; author={Milner, Robin},</span></p><p class="c1"><span class="c5">&nbsp; journal={Journal of computer and system sciences},</span></p><p class="c1"><span class="c5">&nbsp; volume={17},</span></p><p class="c1"><span class="c5">&nbsp; number={3},</span></p><p class="c1"><span class="c5">&nbsp; pages={348--375},</span></p><p class="c1"><span class="c5">&nbsp; year={1978},</span></p><p class="c1"><span class="c5">&nbsp; publisher={Elsevier}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref13" id="ftnt13">[13]</a><span class="c5">&nbsp;@article{wells1999typability,</span></p><p class="c1"><span class="c5">&nbsp; title={Typability and type checking in System F are equivalent and undecidable},</span></p><p class="c1"><span class="c5">&nbsp; author={Wells, Joe B},</span></p><p class="c1"><span class="c5">&nbsp; journal={Annals of Pure and Applied Logic},</span></p><p class="c1"><span class="c5">&nbsp; volume={98},</span></p><p class="c1"><span class="c5">&nbsp; number={1-3},</span></p><p class="c1"><span class="c5">&nbsp; pages={111--156},</span></p><p class="c1"><span class="c5">&nbsp; year={1999},</span></p><p class="c1"><span class="c5">&nbsp; publisher={Elsevier}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref14" id="ftnt14">[14]</a><span class="c5">&nbsp;@book{harper1986standard,</span></p><p class="c1"><span class="c5">&nbsp; title={Standard ml},</span></p><p class="c1"><span class="c5">&nbsp; author={Harper, Robert and MacQueen, David and Milner, Robin},</span></p><p class="c1"><span class="c5">&nbsp; year={1986},</span></p><p class="c1"><span class="c5">&nbsp; publisher={Department of Computer Science, University of Edinburgh}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref15" id="ftnt15">[15]</a><span class="c5">&nbsp;@article{hall1996type,</span></p><p class="c1"><span class="c5">&nbsp; title={Type classes in Haskell},</span></p><p class="c1"><span class="c5">&nbsp; author={Hall, Cordelia V and Hammond, Kevin and Peyton Jones, Simon L and Wadler, Philip L},</span></p><p class="c1"><span class="c5">&nbsp; journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},</span></p><p class="c1"><span class="c5">&nbsp; volume={18},</span></p><p class="c1"><span class="c5">&nbsp; number={2},</span></p><p class="c1"><span class="c5">&nbsp; pages={109--138},</span></p><p class="c1"><span class="c5">&nbsp; year={1996},</span></p><p class="c1"><span class="c5">&nbsp; publisher={ACM New York, NY, USA}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref16" id="ftnt16">[16]</a><span class="c5">&nbsp;@book{jones2003qualified,</span></p><p class="c1"><span class="c5">&nbsp; title={Qualified types: theory and practice},</span></p><p class="c1"><span class="c5">&nbsp; author={Jones, Mark P},</span></p><p class="c1"><span class="c5">&nbsp; number={9},</span></p><p class="c1"><span class="c5">&nbsp; year={2003},</span></p><p class="c1"><span class="c5">&nbsp; publisher={Cambridge University Press}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref17" id="ftnt17">[17]</a><span class="c5">&nbsp;@inproceedings{jones2000type,</span></p><p class="c1"><span class="c5">&nbsp; title={Type classes with functional dependencies},</span></p><p class="c1"><span class="c5">&nbsp; author={Jones, Mark P},</span></p><p class="c1"><span class="c5">&nbsp; booktitle={European Symposium on Programming},</span></p><p class="c1"><span class="c5">&nbsp; pages={230--244},</span></p><p class="c1"><span class="c5">&nbsp; year={2000},</span></p><p class="c1"><span class="c5">&nbsp; organization={Springer}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref18" id="ftnt18">[18]</a><span class="c5">&nbsp;@article{peyton2006simple,</span></p><p class="c1"><span class="c5">&nbsp; title={Simple unification-based type inference for GADTs},</span></p><p class="c1"><span class="c5">&nbsp; author={Peyton Jones, Simon and Vytiniotis, Dimitrios and Weirich, Stephanie and Washburn, Geoffrey},</span></p><p class="c1"><span class="c5">&nbsp; journal={ACM SIGPLAN Notices},</span></p><p class="c1"><span class="c5">&nbsp; volume={41},</span></p><p class="c1"><span class="c5">&nbsp; number={9},</span></p><p class="c1"><span class="c5">&nbsp; pages={50--61},</span></p><p class="c1"><span class="c5">&nbsp; year={2006},</span></p><p class="c1"><span class="c5">&nbsp; publisher={ACM New York, NY, USA}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref19" id="ftnt19">[19]</a><span class="c5">&nbsp;@article{vytiniotis2011outsidein,</span></p><p class="c1"><span class="c5">&nbsp; title={OutsideIn (X) Modular type inference with local assumptions},</span></p><p class="c1"><span class="c5">&nbsp; author={Vytiniotis, Dimitrios and Jones, Simon Peyton and Schrijvers, Tom and Sulzmann, Martin},</span></p><p class="c1"><span class="c5">&nbsp; journal={Journal of functional programming},</span></p><p class="c1"><span class="c5">&nbsp; volume={21},</span></p><p class="c1"><span class="c5">&nbsp; number={4-5},</span></p><p class="c1"><span class="c5">&nbsp; pages={333--412},</span></p><p class="c1"><span class="c5">&nbsp; year={2011},</span></p><p class="c1"><span class="c5">&nbsp; publisher={Cambridge University Press}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref20" id="ftnt20">[20]</a><span class="c5">&nbsp;@inproceedings{vytiniotis2010let,</span></p><p class="c1"><span class="c5">&nbsp; title={Let should not be generalized},</span></p><p class="c1"><span class="c5">&nbsp; author={Vytiniotis, Dimitrios and Peyton Jones, Simon and Schrijvers, Tom},</span></p><p class="c1"><span class="c5">&nbsp; booktitle={Proceedings of the 5th ACM SIGPLAN workshop on Types in language design and implementation},</span></p><p class="c1"><span class="c5">&nbsp; pages={39--50},</span></p><p class="c1"><span class="c5">&nbsp; year={2010}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref21" id="ftnt21">[21]</a><span class="c5">&nbsp;@article{milner1978theory,</span></p><p class="c1"><span class="c5">&nbsp; title={A theory of type polymorphism in programming},</span></p><p class="c1"><span class="c5">&nbsp; author={Milner, Robin},</span></p><p class="c1"><span class="c5">&nbsp; journal={Journal of computer and system sciences},</span></p><p class="c1"><span class="c5">&nbsp; volume={17},</span></p><p class="c1"><span class="c5">&nbsp; number={3},</span></p><p class="c1"><span class="c5">&nbsp; pages={348--375},</span></p><p class="c1"><span class="c5">&nbsp; year={1978},</span></p><p class="c1"><span class="c5">&nbsp; publisher={Elsevier}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref22" id="ftnt22">[22]</a><span class="c5">&nbsp;@article{lee1998proofs,</span></p><p class="c1"><span class="c5">&nbsp; title={Proofs about a folklore let-polymorphic type inference algorithm},</span></p><p class="c1"><span class="c5">&nbsp; author={Lee, Oukseh and Yi, Kwangkeun},</span></p><p class="c1"><span class="c5">&nbsp; journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},</span></p><p class="c1"><span class="c5">&nbsp; volume={20},</span></p><p class="c1"><span class="c5">&nbsp; number={4},</span></p><p class="c1"><span class="c5">&nbsp; pages={707--723},</span></p><p class="c1"><span class="c5">&nbsp; year={1998},</span></p><p class="c1"><span class="c5">&nbsp; publisher={ACM New York, NY, USA}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref23" id="ftnt23">[23]</a><span class="c5">&nbsp;@book{heeren2005top,</span></p><p class="c1"><span class="c5">&nbsp; title={Top quality type error messages},</span></p><p class="c1"><span class="c5">&nbsp; author={Heeren, Bastiaan J},</span></p><p class="c1"><span class="c5">&nbsp; year={2005},</span></p><p class="c1"><span class="c5">&nbsp; publisher={Utrecht University}</span></p><p class="c1"><span class="c5">}</span></p></div><div><p class="c1"><a href="#ftnt_ref24" id="ftnt24">[24]</a><span class="c17">&nbsp;</span><span class="c12"><a class="c11" href="https://www.google.com/url?q=https://github.com/mbg/cs310&amp;sa=D&amp;source=editors&amp;ust=1613332984348000&amp;usg=AOvVaw0H6hsLFPs6aBY_OmwPwNDO">https://github.com/mbg/cs310</a></span></p></div></body></html>